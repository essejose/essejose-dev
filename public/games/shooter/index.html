<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Helicopter Shooter</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Helicopter Shooter">
    <meta name="keywords" content="Helicopter Shooter, Game, HTML5, Canvas, JavaScript">
    <meta name="author" content="Essejose">
    <meta name="robots" content="index, follow">
    <meta name="googlebot" content="index, follow">
    <meta name="google" content="notranslate">
    <meta name="google-site-verification" content="google-site-verification=google-site-verification">
    <link rel="canonical" href="https://essejose.com/games/shooter">
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-W6NSHMJS');</script>
    <!-- End Google Tag Manager -->
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
        background: #cceeff;
      }
    </style>
  </head>
  <body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-W6NSHMJS"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <canvas id="game"></canvas>
    <script>
      const canvas = document.getElementById("game");
      canvas.addEventListener("touchstart", handleTouch);
      canvas.addEventListener("touchmove", handleTouch);

      const ctx = canvas.getContext("2d");
      function handleTouch(e) {
        e.preventDefault(); // evita o scroll em dispositivos m√≥veis

        const touch = e.touches[0]; // usa o primeiro toque
        const rect = canvas.getBoundingClientRect();
        const touchX = touch.clientX - rect.left;
        const touchY = touch.clientY - rect.top;

        // Define o alvo para movimento suave
        game.player.targetX = touchX - game.player.width / 2;
        game.player.targetY = touchY - game.player.height / 2;
      }
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      const ASSETS = {
        helicopter: "./images/player.png",
        grass: "https://placehold.co/20x20/88cc88/000?text=G",
        health: "https://placehold.co/20x20/ff66cc/000?text=H",
      };

      const IMAGES = {};
      const CONTROLSMODES = {
        HELICOPTER: "helicopter",
        PLANE: "plane",
      };
      let keys = {};
      let controlMode = CONTROLSMODES.PLANE;
      document.addEventListener("keydown", (e) => {
        keys[e.code] = true;
        if (e.code === "KeyM") {
          controlMode =
            controlMode === CONTROLSMODES.HELICOPTER
              ? CONTROLSMODES.PLANE
              : CONTROLSMODES.HELICOPTER;
        }
      });

      document.addEventListener("keydown", (e) => (keys[e.code] = true));
      document.addEventListener("keyup", (e) => (keys[e.code] = false));

      function loadImages(sources, callback) {
        let loaded = 0;
        const total = Object.keys(sources).length;
        for (const key in sources) {
          IMAGES[key] = new Image();
          IMAGES[key].src = sources[key];
          IMAGES[key].onload = () => {
            loaded++;
            if (loaded === total) callback();
          };
        }
      }
      const HitEffectManager = {
        spawnEffect(x, y, type = "spark", intensity = 1) {
          switch (type) {
            case "spark": // Fa√≠sca leve
              for (let i = 0; i < 4 * intensity; i++) {
                game.particles.push(new ExplosionParticle(x, y, "yellow"));
              }
              break;

            case "explosion": // Explos√£o forte
              for (let i = 0; i < 10 * intensity; i++) {
                const color = Math.random() < 0.5 ? "orange" : "red";
                game.particles.push(new ExplosionParticle(x, y, color));
              }
              game.shakeX = 4 * intensity;
              game.shakeY = 3 * intensity;
              break;

            case "laser":
              for (let i = 0; i < 6 * intensity; i++) {
                game.particles.push(new ExplosionParticle(x, y, "cyan"));
              }
              break;

            case "hitPlayer":
              for (let i = 0; i < 4; i++) {
                game.particles.push(new ExplosionParticle(x, y, "white"));
              }
              game.shakeX = 2;
              break;

            default:
              console.warn("Efeito desconhecido:", type);
          }
        },
      };
      const WeaponTypes = {
        BASIC: {
          speed: 8,
          damage: 2,
          color: "red",
          name: "BASIC",
          cooldown: 15,
          isAuxiliary: false,
          hitEffect: "spark",
          wobbleY: 0.8, // üëà pequena varia√ß√£o vertical por frame
        },
        LASER: {
          speed: 12,
          damage: 3,
          color: "lime",
          name: "LASER",
          cooldown: 5,
          isAuxiliary: false,
          hitEffect: "laser",
        },
        SPREAD: {
          speed: 7,
          damage: 2,
          spread: true,
          color: "orange",
          name: "SPREAD",
          cooldown: 20,
          isAuxiliary: false,
          hitEffect: "spark",
        },
      };

      const AuxiliaryWeaponTypes = {
        MISSILE: {
          speed: 7,
          damage: 3,
          color: "blue",
          name: "MISSILE",
          cooldown: 50,
          homing: true,
          isAuxiliary: true,
          hitEffect: "explosion",
        },
        ORBITAL: {
          name: "ORBITAL",
          color: "cyan",
          cooldown: 60,
          speed: 6,
          damage: 2,
          isAuxiliary: true,
          orbit: true,
          hitEffect: "spark",
        },
        MINE: {
          speed: 6,
          damage: 4,
          color: "black",
          name: "MINE",
          cooldown: 80,
          isAuxiliary: true,
          hitEffect: "explosion",
        },
      };

      class ProximityMineProjectile {
        constructor(x, y, damage = 4, radius = 50) {
          this.x = x;
          this.y = y;
          this.damage = damage;
          this.radius = radius;
          this.width = 12;
          this.height = 12;
          this.timer = 300; // 5 segundos
          this.armed = false;
          this.armDelay = 30;
          this.blinkCounter = 0;
        }

        draw() {
          if (this.armed) {
            // Pisca em vermelho e amarelo
            const blink = Math.floor(this.blinkCounter / 10) % 2 === 0;
            ctx.fillStyle = blink ? "red" : "yellow";
          } else {
            ctx.fillStyle = "gray";
          }

          ctx.beginPath();
          ctx.arc(this.x, this.y, this.width / 2, 0, Math.PI * 2);
          ctx.fill();

          // Mostra raio de detec√ß√£o
          if (this.armed) {
            ctx.strokeStyle = "rgba(255,0,0,0.3)";
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
            ctx.stroke();
          }
        }

        update() {
          if (this.armDelay > 0) {
            this.armDelay--;
          } else {
            this.armed = true;
          }

          this.timer--;
          this.blinkCounter++;

          if (!this.armed) return;

          for (let e of game.enemies) {
            const closestX = Math.max(e.x, Math.min(this.x, e.x + e.width));
            const closestY = Math.max(e.y, Math.min(this.y, e.y + e.height));
            const dx = this.x - closestX;
            const dy = this.y - closestY;
            const distSq = dx * dx + dy * dy;

            if (distSq < this.radius * this.radius) {
              this.explode();
              return;
            }
          }

          if (this.timer <= 0) {
            this.explode();
          }
        }

        explode() {
          game.damageTexts.push(new DamageText(this.x, this.y, "üí•", "red"));

          for (let en of game.enemies) {
            const closestX = Math.max(en.x, Math.min(this.x, en.x + en.width));
            const closestY = Math.max(en.y, Math.min(this.y, en.y + en.height));
            const dx = this.x - closestX;
            const dy = this.y - closestY;
            const distSq = dx * dx + dy * dy;

            if (distSq < this.radius * this.radius) {
              if (en.takeDamage) en.takeDamage(this.damage);
            }
          }

          this.dead = true;
          for (let i = 0; i < 15; i++) {
            game.particles.push(
              new ExplosionParticle(
                this.x,
                this.y,
                Math.random() < 0.5 ? "orange" : "gray"
              )
            );
          }
        }
      }

      class ExplosionParticle {
        constructor(x, y, color = "orange") {
          this.x = x;
          this.y = y;
          this.vx = (Math.random() - 0.5) * 4;
          this.vy = (Math.random() - 0.5) * 4;
          this.alpha = 1;
          this.radius = 2 + Math.random() * 2;
          this.color = color;
          this.life = 30 + Math.random() * 20;
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.life--;
          this.alpha = Math.max(0, this.life / 40);
        }

        draw() {
          ctx.globalAlpha = this.alpha;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        get dead() {
          return this.life <= 0;
        }
      }

      class OrbitalDrone {
        constructor(player, angle, weaponInstance) {
          this.player = player;
          this.angle = angle; // em radianos
          this.radius = 50;
          this.weapon = weaponInstance;
          this.cooldown = 0;
        }

        update(index, total) {
          // Orbita baseado em tempo + √≠ndice (para m√∫ltiplos drones)
          const rotationSpeed = 0.02;
          this.angle += rotationSpeed;

          // Calcula a posi√ß√£o em volta do player
          const px = this.player.x + this.player.width / 2;
          const py = this.player.y + this.player.height / 2;
          this.x = px + Math.cos(this.angle) * this.radius;
          this.y = py + Math.sin(this.angle) * this.radius;

          // Tiro autom√°tico
          if (this.cooldown <= 0) {
            const vx = this.weapon.speed;
            const vy = 0;
            game.projectiles.push(new Projectile(this.x, this.y, this.weapon));
            this.cooldown = this.weapon.cooldown;
          } else {
            this.cooldown--;
          }
        }

        draw() {
          ctx.fillStyle = this.weapon.color || "cyan";
          ctx.beginPath();
          ctx.arc(this.x, this.y, 6, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      class WeaponInstance {
        constructor(type, level = 1) {
          this.type = type; // referencia ao tipo base (WeaponTypes ou AuxiliaryWeaponTypes)
          this.level = level;
          this.damage = type.damage + (level - 1);
          this.cooldown = Math.max(5, type.cooldown - (level - 1));
          this.cooldownCounter = 0;
          this.spread = type.spread || false;
          this.homing = type.homing || false;
          this.color = type.color;
          this.name = type.name;
          this.speed = type.speed;
        }

        levelUp() {
          this.level++;
          this.damage++;
          this.cooldown = Math.max(5, this.type.cooldown - (this.level - 1));
        }

        readyToShoot() {
          return this.cooldownCounter <= 0;
        }

        updateCooldown(player) {
          let factor = 1;
          if (player?.rapidFireTimer > 0) {
            factor = 2; // 2x mais r√°pido (cooldown reduzido pela metade)
          }

          if (this.cooldownCounter > 0) {
            this.cooldownCounter -= factor;
          }
        }

        resetCooldown() {
          this.cooldownCounter = this.cooldown;
        }
      }

      const DropTypes = {
        LIFE: {
          name: "LIFE",
          color: "green",
          apply(player) {
            if (player.health < player.maxHealth) {
              player.health++;
              game.damageTexts.push(
                new DamageText(player.x, player.y, "+1 HP", "green")
              );
            }
          },
        },
        SHIELD: {
          name: "SHIELD",
          color: "cyan",
          apply(player) {
            player.invincibilityTimer = 240;
            game.damageTexts.push(
              new DamageText(player.x, player.y, "Shield!", "cyan")
            );
          },
        },
        BOMB: {
          name: "BOMB",
          color: "red",
          apply(player) {
            const count = game.enemies.length;
            game.enemies = [];
            game.projectiles = game.projectiles.filter((p) => !p.homing);

            game.damageTexts.push(
              new DamageText(player.x, player.y, `üí£ ${count} enemies`, "red")
            );
          },
        },
        SPEED: {
          name: "SPEED",
          color: "orange",
          apply(player) {
            player.speedBoost = 1.5;
            player.speedBoostTimer = 300;
            game.damageTexts.push(
              new DamageText(player.x, player.y, "Speed!", "orange")
            );
          },
        },
        RAPID: {
          name: "RAPID",
          color: "magenta",
          apply(player) {
            player.rapidFireTimer = 300; // dura 5 segundos (60 FPS)
            game.damageTexts.push(
              new DamageText(player.x, player.y, "Rapid Fire!", "magenta")
            );
          },
        },
      };

      class DropInstance {
        constructor(x, y, dropType) {
          this.x = x;
          this.y = y;
          this.width = 20;
          this.height = 20;
          this.dropType = dropType;
        }

        draw() {
          ctx.fillStyle = this.dropType.color;
          ctx.fillRect(this.x, this.y, this.width, this.height);
          ctx.fillStyle = "black";
          ctx.font = "12px Arial";
          ctx.fillText(this.dropType.name[0], this.x + 6, this.y + 14); // Letra do tipo
        }

        update() {
          this.x -= 2;
        }

        apply(player) {
          this.dropType.apply(player);
        }
      }

      function createWeapon(type, level = 1) {
        const base = WeaponTypes[type];
        return new WeaponInstance(base, level);
      }

      // Adicionar classe PowerUp de arma
      class WeaponPowerUp {
        constructor(x, y, weaponType) {
          this.x = x;
          this.y = y;
          this.width = 20;
          this.height = 20;
          this.weaponType = weaponType;
        }

        draw() {
          ctx.fillStyle = this.weaponType.color;
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        update() {
          this.x -= 2;
        }

        apply(player) {
          const same = player.primaryWeapon.name === this.weaponType.name;

          if (same) {
            player.primaryWeapon.levelUp();
          } else {
            console.log(this.weaponType);
            const isAuxiliary = this.weaponType.isAuxiliary === true;

            if (isAuxiliary) {
              const existing = player.auxiliaryWeapons.find(
                (w) => w.name === this.weaponType.name
              );
              if (existing) {
                existing.levelUp();
              } else if (player.auxiliaryWeapons.length < 5) {
                player.auxiliaryWeapons.push(
                  new WeaponInstance(this.weaponType)
                );
                game.damageTexts.push(
                  new DamageText(this.x, this.y, "New Auxiliary Weapon", "gray")
                );
              }
            } else {
              // Ex: game.damageTexts.push(new DamageText(this.x, this.y, "Incompat√≠vel", "gray"));
            }
          }
        }
      }

      class PowerUp {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.width = 20;
          this.height = 20;
        }

        draw() {
          ctx.drawImage(IMAGES.health, this.x, this.y, this.width, this.height);
        }

        update() {
          this.x -= 2;
        }
      }

      class Player {
        constructor() {
          this.x = 100;
          this.y = canvas.height * 0.5;
          this.width = 80;
          this.height = 80;
          this.velocity = 0;
          this.gravity = 0.3;
          this.lift = -0.6;
          this.cooldown = 0;
          this.airborne = true;
          this.maxHealth = 5;
          this.health = this.maxHealth;
          this.invincible = false;
          this.invincibilityTimer = 0;
          this.speed = 8;
          this.rapidFireTimer = 0;
          this.orbitalDrones = [];

          // Propriedades para movimento suave no mobile
          this.targetX = null;
          this.targetY = null;
          this.moveSpeed = 0.15; // Velocidade de interpola√ß√£o (0.1 = mais lento, 0.3 = mais r√°pido)

          // Propriedades para inclina√ß√£o (tilt) ao se mover
          this.tiltAngle = 0; // √Çngulo atual de inclina√ß√£o
          this.maxTilt = 0.15; // Inclina√ß√£o m√°xima em radianos (~8 graus)
          this.tiltSpeed = 0.1; // Velocidade de transi√ß√£o da inclina√ß√£o
          this.prevX = this.x; // Posi√ß√£o anterior para calcular movimento
          this.prevY = this.y;

          // Propriedades para anima√ß√£o da h√©lice traseira
          this.propellerAngle = 0;
          this.propellerSpeed = 0.3; // Velocidade de rota√ß√£o da h√©lice
          this.propellerRadius = 8; // Raio da h√©lice

          // Propriedades para anima√ß√£o do rotor principal
          this.mainRotorAngle = 0;
          this.mainRotorSpeed = 0.2; // Velocidade de rota√ß√£o do rotor principal
          this.mainRotorRadius = 30; // Raio do rotor principal

          // Armas
          this.primaryWeapon = new WeaponInstance(WeaponTypes.SPREAD);
          this.auxiliaryWeapons = [
            new WeaponInstance(AuxiliaryWeaponTypes.ORBITAL),
          ];
        }

        draw() {
          // Salva o estado do canvas antes de aplicar rota√ß√£o
          ctx.save();
          
          // Define o ponto de rota√ß√£o no centro do helic√≥ptero
          const centerX = this.x + this.width / 2;
          const centerY = this.y + this.height / 2;
          
          // Move para o centro do helic√≥ptero
          ctx.translate(centerX, centerY);
          
          // Aplica a rota√ß√£o (inclina√ß√£o)
          ctx.rotate(this.tiltAngle);
          
          // Move de volta para desenhar o helic√≥ptero
          ctx.translate(-centerX, -centerY);
          
          // Desenha o helic√≥ptero com transpar√™ncia se invenc√≠vel
          if (
            this.invincible &&
            Math.floor(this.invincibilityTimer / 5) % 2 === 0
          ) {
            ctx.globalAlpha = 0.5;
          }
          ctx.drawImage(
            IMAGES.helicopter,
            this.x,
            this.y,
            this.width,
            this.height
          );
          ctx.globalAlpha = 1.0;

          // Desenha a h√©lice traseira animada
          this.drawPropeller();
          
          // Desenha o rotor principal animado
          this.drawMainRotor();

          // Restaura o estado do canvas (remove a rota√ß√£o)
          ctx.restore();

          // Desenha a barra de vida (sem rota√ß√£o)
          const barWidth = 60;
          const barHeight = 8;
          const barX = this.x;
          const barY = this.y - 12;
          ctx.fillStyle = "gray";
          ctx.fillRect(barX, barY, barWidth, barHeight);
          ctx.fillStyle = "limegreen";
          ctx.fillRect(
            barX,
            barY,
            barWidth * (this.health / this.maxHealth),
            barHeight
          );
          ctx.strokeStyle = "black";
          ctx.strokeRect(barX, barY, barWidth, barHeight);

          if (this.orbitalDrones) {
            this.orbitalDrones.forEach((drone) => drone.draw());
          }
        }

        drawPropeller() {
          const centerX = this.x + this.width / 27;
          const centerY = this.y + this.height / 2.7;
          
          // Salva o estado atual do canvas
          ctx.save();
          
          // Move o ponto de rota√ß√£o para o centro do player
          ctx.translate(centerX, centerY);
          
          // Rotaciona baseado no √¢ngulo da h√©lice
          ctx.rotate(this.propellerAngle);
          
          // Desenha as p√°s da h√©lice
          ctx.strokeStyle = "#333";
          ctx.lineWidth = 2;
          
          // P√° 1 (horizontal)
          ctx.beginPath();
          ctx.moveTo(-this.propellerRadius, 0);
          ctx.lineTo(this.propellerRadius, 0);
          ctx.stroke();
          
          // P√° 2 (vertical)
          ctx.beginPath();
          ctx.moveTo(0, -this.propellerRadius);
          ctx.lineTo(0, this.propellerRadius);
          ctx.stroke();
          
          // Desenha o centro da h√©lice
          ctx.fillStyle = "#666";
          ctx.beginPath();
          ctx.arc(0, 0, .5, 0, Math.PI * 2);
          ctx.fill();
          
          // Restaura o estado do canvas
          ctx.restore();
        }

        drawMainRotor() {
          const centerX = this.x + 47;
          const centerY = this.y + 25; // Posiciona acima do helic√≥ptero
          
          // Salva o estado atual do canvas
          ctx.save();
          
          // Move o ponto de rota√ß√£o para o centro do rotor
          ctx.translate(centerX, centerY);
          
          // Calcula a opacidade baseada no √¢ngulo para simular o efeito de "aparecer e sumir" (flicker/blur)
          // A opacidade ir√° oscilar entre 0.3 e 0.8, dando a impress√£o de movimento r√°pido.
          const minOpacity = 0.3;
          const maxOpacity = 0.8;
          const opacity = minOpacity + (maxOpacity - minOpacity) * Math.abs(Math.sin(this.mainRotorAngle * 2)); 
          
          ctx.globalAlpha = opacity; // Aplica a transpar√™ncia

          // Desenha as p√°s do rotor principal como uma linha horizontal fixa
          ctx.strokeStyle = "#444";
          ctx.lineWidth = 4;
          
          // P√° 1 (horizontal) - parte esquerda
          ctx.beginPath();
          ctx.moveTo(-this.mainRotorRadius, 0);
          ctx.lineTo(-2, 0); // Desenha at√© a esquerda do centro
          ctx.stroke();

          // P√° 2 (horizontal) - parte direita
          ctx.beginPath();
          ctx.moveTo(2, 0); // Desenha a partir da direita do centro
          ctx.lineTo(this.mainRotorRadius, 0);
          ctx.stroke();
          
          // Desenha o centro do rotor
          ctx.beginPath();
          ctx.arc(0, 0, 2, 0, Math.PI * 2);
          ctx.fillStyle = "#555";
          ctx.fill();

          ctx.globalAlpha = 1; // Restaura a opacidade global para n√£o afetar outros desenhos
          // Restaura o estado do canvas
          ctx.restore();
        }

        update() {
          // Movimento suave para mobile
          if (this.targetX !== null && this.targetY !== null) {
            const dx = this.targetX - this.x;
            const dy = this.targetY - this.y;
            
            // Interpola√ß√£o suave
            this.x += dx * this.moveSpeed;
            this.y += dy * this.moveSpeed;
            
            // Para quando estiver pr√≥ximo o suficiente do alvo
            if (Math.abs(dx) < 2 && Math.abs(dy) < 2) {
              this.x = this.targetX;
              this.y = this.targetY;
              this.targetX = null;
              this.targetY = null;
            }
          }

          // Atualiza anima√ß√£o da h√©lice traseira
          this.propellerAngle += this.propellerSpeed;
          
          // Atualiza anima√ß√£o do rotor principal
          this.mainRotorAngle += this.mainRotorSpeed;

          // Calcula inclina√ß√£o baseada no movimento horizontal
          const velocityX = this.x - this.prevX;
          const velocityY = this.y - this.prevY;
          
          // Inclina√ß√£o para frente quando movendo para direita
          let targetTilt = 0;
          if (velocityX > 0.5) {
            targetTilt = this.maxTilt; // Inclina para frente
          } else if (velocityX < -0.5) {
            targetTilt = -this.maxTilt * 0.5; // Inclina levemente para tr√°s
          }
          
          // Inclina√ß√£o adicional baseada no movimento vertical
          if (velocityY < -0.5) {
            targetTilt += this.maxTilt * 0.3; // Inclina mais para frente ao subir
          } else if (velocityY > 0.5) {
            targetTilt -= this.maxTilt * 0.3; // Inclina para tr√°s ao descer
          }
          
          // Suaviza a transi√ß√£o do √¢ngulo de inclina√ß√£o
          this.tiltAngle += (targetTilt - this.tiltAngle) * this.tiltSpeed;
          
          // Atualiza posi√ß√£o anterior
          this.prevX = this.x;
          this.prevY = this.y;

          if (controlMode === CONTROLSMODES.HELICOPTER) {
            if (keys["Space"]) {
              this.velocity += this.lift;
            }

            this.velocity += this.gravity;
            this.y += this.velocity;

            const groundY = canvas.height - this.height - canvas.height * 0.1;
            if (this.y >= groundY) {
              this.y = groundY;
              this.velocity = 0;
              this.airborne = false;
            } else {
              this.airborne = true;
            }

            if (this.y < 0) {
              this.y = 0;
              this.velocity = 0;
            }
          } else if (controlMode === CONTROLSMODES.PLANE) {
            const speed = this.speed * (this.speedBoost || 1);
            if (keys["ArrowUp"] || keys["KeyW"]) this.y -= speed;
            if (keys["ArrowDown"] || keys["KeyS"]) this.y += speed;
            if (keys["ArrowLeft"] || keys["KeyA"]) this.x -= speed;
            if (keys["ArrowRight"] || keys["KeyD"]) this.x += speed;

            const groundY = canvas.height - this.height - canvas.height * 0.1;
            if (this.y >= groundY) this.y = groundY;
            if (this.y < 0) this.y = 0;
            if (this.x < 0) this.x = 0;
            if (this.x + this.width > canvas.width)
              this.x = canvas.width - this.width;
          }

          this.primaryWeapon.updateCooldown(this);
          if (this.primaryWeapon.readyToShoot()) {
            this.shoot();
            this.primaryWeapon.resetCooldown();
          }

          this.auxiliaryWeapons.forEach((weapon) => {
            weapon.updateCooldown(this);
            if (weapon.readyToShoot()) {
              this.fireWeapon(weapon);
              weapon.resetCooldown();
            }
          });

          if (this.speedBoostTimer > 0) {
            this.speedBoostTimer--;
            if (this.speedBoostTimer <= 0) {
              this.speedBoost = 1;
            }
          }

          if (this.rapidFireTimer > 0) {
            this.rapidFireTimer--;
          }

          if (this.cooldown > 0) this.cooldown--;
          if (this.invincibilityTimer > 0) {
            this.invincibilityTimer--;
            this.invincible = true;
          } else {
            this.invincible = false;
          }

          if (!this.orbitalDrones) this.orbitalDrones = [];

          const orbitalWeapons = this.auxiliaryWeapons.filter(
            (w) => w.name === "ORBITAL"
          );

          if (orbitalWeapons.length > 0) {
            const weapon = orbitalWeapons[0];
            const count = Math.min(weapon.level, 4); // at√© 3 drones
            while (this.orbitalDrones.length < count) {
              this.orbitalDrones.push(
                new OrbitalDrone(this, Math.random() * Math.PI * 2, weapon)
              );
            }
            while (this.orbitalDrones.length > count) {
              this.orbitalDrones.pop();
            }

            this.orbitalDrones.forEach((drone, i) => drone.update(i, count));
          }
        }

        shoot() {
          // Atira com arma principal
          if (this.cooldown <= 0) {
            this.fireWeapon(this.primaryWeapon);
            this.cooldown = this.primaryWeapon.cooldown;
          }
        }

        fireWeapon(weapon) {
          const centerY = this.y + this.height / 2;

          if (weapon.name === "MINE") {
            const mineX = this.x + this.width + 20;
            const mineY = this.y + this.height / 2;
            game.projectiles.push(
              new ProximityMineProjectile(mineX, mineY, weapon.damage)
            );
            return;
          }

          if (weapon.spread) {
            const angles = [-2, 0, 2];
            for (let angle of angles) {
              game.projectiles.push(
                new Projectile(this.x + this.width, centerY, weapon, angle)
              );
            }
          } else {
            game.projectiles.push(
              new Projectile(this.x + this.width, centerY, weapon)
            );
          }
        }
      }

      class Projectile {
        constructor(x, y, weapon, verticalOffset = 0) {
          this.x = x;
          this.y = y;
          this.speed = weapon.speed;
          this.damage = weapon.damage;
          this.color = weapon.color;
          this.weaponName = weapon.name;
          this.width = 10;
          this.height = 3;
          this.verticalOffset = verticalOffset;
          this.homing = weapon.homing || false;
          this.lifetime = 300;
          this.wobbleY = weapon.wobbleY || 0;
          this.baseY = this.y;
          this.frameCount = 0;

          this.vx = this.speed;
          this.vy = verticalOffset;

          if (this.homing) {
            this.target = null;
          }
        }

        draw() {
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        update() {
          if (this.homing) {
            this.lifetime--;
            if (this.lifetime <= 0) this.dead = true;

            if (
              !this.target ||
              this.target.health <= 0 ||
              this.target.x + this.target.width < 0
            ) {
              const newTarget = game.enemies
                .filter((e) => e.x > game.player.x && e.health > 0)
                .sort((a, b) => a.x - b.x)[0];

              if (newTarget) {
                this.target = newTarget;
              } else {
                this.x += this.vx;
                this.y += this.vy;
                this.checkOutOfBounds();
                return;
              }
            }

            // Ajusta trajet√≥ria em dire√ß√£o ao alvo travado
            const dx = this.target.x + this.target.width / 2 - this.x;
            const dy = this.target.y + this.target.height / 2 - this.y;
            const mag = Math.sqrt(dx * dx + dy * dy) || 1;
            this.vx = (dx / mag) * this.speed;
            this.vy = (dy / mag) * this.speed;

            this.x += this.vx;
            this.y += this.vy;
          } else {
            // Proj√©til comum
            this.x += this.speed;
            this.frameCount++;

            if (this.wobbleY) {
                const noise = (Math.random() - 0.5) * this.wobbleY * 2; // ru√≠do aleat√≥rio leve
                this.y += noise;
            } else {
              this.y += this.verticalOffset;
            }
          }

          this.checkOutOfBounds();
        }

        checkOutOfBounds() {
          if (
            this.x > canvas.width ||
            this.x + this.width < 0 ||
            this.y < 0 ||
            this.y > canvas.height
          ) {
            this.dead = true;
          }
        }
      }

      class EnemyProjectile {
        constructor(x, y, damage = 1) {
          this.x = x;
          this.y = y;
          this.speed = 4;
          this.width = 8;
          this.height = 3;
          this.damage = damage;
        }

        draw() {
          ctx.fillStyle = "purple";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        update() {
          this.x -= this.speed;
        }
      }

      class EnemyProjectileAngular {
        constructor(x, y, targetX, targetY, damage = 2) {
          this.x = x;
          this.y = y;
          const dx = targetX - x;
          const dy = targetY - y;
          const magnitude = Math.sqrt(dx * dx + dy * dy);
          this.vx = (dx / magnitude) * 4;
          this.vy = (dy / magnitude) * 4;
          this.width = 8;
          this.height = 3;
          this.damage = damage;
        }

        draw() {
          ctx.fillStyle = "orange";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
        }
      }
      class Enemy {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.width = 20;
          this.height = 60;
          this.speed = 2;
          this.cooldown = Math.random() * 180 + 60;
          this.damage = 1;
        }

        draw() {
          ctx.fillStyle = "#594700";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        update() {
          this.x -= this.speed;
          this.cooldown--;
          if (this.cooldown <= 0) {
            game.enemyProjectiles.push(
              new EnemyProjectile(this.x, this.y + this.height / 2, this.damage)
            );
            this.cooldown = Math.random() * 180 + 60;
          }
        }
      }

      class MiniBoss extends Enemy {
        constructor(x, y) {
          super(x, y);
          this.width = 120;
          this.height = 80;
          this.maxHealth = 50;
          this.health = 50;
          this.speed = 1;
          this.cooldown = 90;
        }

        update() {
          const player = game.player;
          const targetX = 400; // posi√ß√£o que o miniboss tenta manter
          const dodgeRange = 100;
          const dodgeIntensity = 3;

          // Inicializa vari√°veis de controle (se ainda n√£o tiverem)
          if (this.dodgeCooldown === undefined) this.dodgeCooldown = 0;
          if (this.evadeDirection === undefined) this.evadeDirection = 0;

          // üü¶ Movimento horizontal inteligente
          const buffer = 30; // margem de seguran√ßa entre o player e o miniboss
          // const targetX = 400;

          if (player.x > this.x + buffer) {
            // Player passou do miniboss ‚Üí miniboss recua
            this.x += 1.5;
          } else if (this.x > targetX + 5) {
            // Retorna suavemente para a posi√ß√£o padr√£o
            this.x -= 1;
          } else if (this.x < targetX - 5) {
            this.x += 1;
          }

          // üü• Evas√£o de proj√©teis
          if (this.dodgeCooldown <= 0) {
            for (let p of game.projectiles) {
              const closeX =
                p.x > this.x - dodgeRange && p.x < this.x + this.width;
              const closeY =
                p.y > this.y - 30 && p.y < this.y + this.height + 30;
              if (closeX && closeY) {
                this.evadeDirection = p.y < this.y ? 1 : -1;
                this.dodgeCooldown = 30;
                break;
              }
            }
          } else {
            this.dodgeCooldown--;
          }

          // Aplica evasiva suavizada
          this.y += this.evadeDirection * dodgeIntensity;
          this.evadeDirection *= 0.9;

          // üü® Segue levemente o player se n√£o estiver esquivando
          if (Math.abs(this.evadeDirection) < 0.1) {
            const dy = (player.y - this.y) * 0.02;
            this.y += dy;
          }

          // üî∫ Ataque padr√£o
          this.cooldown--;
          if (this.cooldown <= 0) {
            for (let i = -1; i <= 1; i++) {
              const angle = i * 0.2;
              const speed = 5;
              const vx = Math.cos(angle) * -speed;
              const vy = Math.sin(angle) * speed;
              game.enemyProjectiles.push(
                new MiniBossProjectile(this.x, this.y + this.height / 2, vx, vy)
              );
            }
            this.cooldown = 90;
          }
        }

        draw() {
          ctx.fillStyle = "#880000";
          ctx.fillRect(this.x, this.y, this.width, this.height);

          ctx.fillStyle = "black";
          ctx.fillRect(this.x, this.y - 10, this.width, 6);
          ctx.fillStyle = "red";
          ctx.fillRect(
            this.x,
            this.y - 10,
            this.width * (this.health / this.maxHealth),
            6
          );
        }

        takeDamage(dmg) {
          this.health -= dmg;
          if (this.health <= 0) {
            this.dead = true;
            game.damageTexts.push(
              new DamageText(this.x, this.y, "Boss Defeated!", "red")
            );
            game.powerUps.push(
              new DropInstance(this.x, this.y, DropTypes.RAPID)
            );
            return true;
          }
          return false;
        }
      }

      class MiniBossProjectile {
        constructor(x, y, vx, vy) {
          this.x = x;
          this.y = y;
          this.vx = vx;
          this.vy = vy;
          this.width = 10;
          this.height = 4;
          this.damage = 2;
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
        }

        draw() {
          ctx.fillStyle = "darkred";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }
      }

      class Tank {
        constructor(x) {
          this.x = x;
          this.y = canvas.height - canvas.height * 0.1 - 40;
          this.width = 60;
          this.height = 40;
          this.speed = 1.2;
          this.cooldown = Math.random() * 180 + 60;
        }

        draw() {
          ctx.fillStyle = "#333";
          ctx.fillRect(this.x, this.y, this.width, this.height);
          ctx.fillStyle = "#666";
          ctx.fillRect(this.x + 10, this.y - 10, 40, 10);
        }

        update() {
          this.x -= this.speed;
          this.cooldown--;
          if (this.cooldown <= 0) {
            const target = game.player;
            game.enemyProjectiles.push(
              new EnemyProjectileAngular(
                this.x,
                this.y + this.height / 2,
                target.x + target.width / 2,
                target.y + target.height / 2
              )
            );
            this.cooldown = Math.random() * 180 + 60;
          }
        }
      }

      class BomberEnemy extends Enemy {
        constructor(x, y) {
          super(x, y);
          this.width = 40;
          this.height = 40;
          this.damage = 1;
        }

        update() {
          this.x -= this.speed;
          this.cooldown--;
          if (this.cooldown <= 0) {
            for (let i = -1; i <= 1; i++) {
              game.enemyProjectiles.push(
                new EnemyProjectile(this.x, this.y + i * 10, this.damage)
              );
            }
            this.cooldown = Math.random() * 150 + 80;
          }
        }

        draw() {
          ctx.fillStyle = "#ff5555";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }
      }

      class SniperEnemy extends Enemy {
        constructor(x, y) {
          super(x, y);
          this.cooldown = 240;
          this.width = 20;
          this.height = 60;
          this.damage = 2;
        }

        update() {
          this.x -= this.speed * 0.5;
          this.cooldown--;
          if (this.cooldown <= 0) {
            const target = game.player;
            game.enemyProjectiles.push(
              new EnemyProjectileAngular(
                this.x,
                this.y + this.height / 2,
                target.x + target.width / 2,
                target.y + target.height / 2,
                this.damage
              )
            );
            this.cooldown = 240;
          }
        }

        draw() {
          ctx.fillStyle = "#3333cc";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }
      }

      class ShieldedEnemy extends Enemy {
        constructor(x, y) {
          super(x, y);
          this.shielded = true;
          this.width = 30;
          this.height = 50;
        }

        draw() {
          ctx.fillStyle = this.shielded ? "#88f" : "#f88";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        hit() {
          if (this.shielded) {
            this.shielded = false;
            return false;
          } else {
            return true;
          }
        }
      }

      class DiveEnemy {
        constructor(x) {
          const player = game.player;
          this.x = x;
          this.y = player.y; // Inicia na mesma altura que o player
          this.width = 30;
          this.height = 30;
          this.speed = 5;
          this.phase = "approaching";
          this.attackSpeed = 6;
          this.exitSpeed = 4;
          this.triggerDistance = 250;
          this.shot = false;
        }

        update() {
          const player = game.player;

          if (this.phase === "approaching") {
            this.x -= this.speed;

            const dx = this.x - (player.x + player.width);
            if (dx < this.triggerDistance) {
              this.phase = "diving";
            }
          } else if (this.phase === "diving") {
            this.y += this.attackSpeed;
            this.x -= this.speed * 0.5;

            if (!this.shot && Math.abs(this.y - player.y) < 30) {
              game.enemyProjectiles.push(
                new EnemyProjectile(this.x, this.y + this.height / 2)
              );
              this.shot = true;
            }

            if (this.y > player.y + 50) {
              this.phase = "exiting";
            }
          } else if (this.phase === "exiting") {
            this.y -= this.exitSpeed;
            this.x -= this.speed * 0.5;
          }
        }

        draw() {
          ctx.fillStyle = "#ffaa00";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }
      }

      class DroneEnemy extends Enemy {
        constructor(x, y) {
          super(x, y);
          this.width = 20;
          this.height = 20;
          this.speed = 2.5;
          this.cooldown = 60 + Math.random() * 60;
          this.damage = 1;
        }

        draw() {
          ctx.fillStyle = "#00ccff";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        update() {
          this.x -= this.speed;
          this.cooldown--;
          if (this.cooldown <= 0) {
            game.enemyProjectiles.push(
              new EnemyProjectile(this.x, this.y + this.height / 2)
            );
            this.cooldown = 90 + Math.random() * 90;
          }
        }
      }

      function dropOnEnemyDeath(enemy) {
        const dropChance = Math.random();

        if (dropChance < 0.1) {
          // 10% de chance de soltar vida
          game.powerUps.push(new PowerUp(enemy.x, enemy.y));
        } else if (dropChance < 0.2) {
          // 10% de chance de soltar arma
          const allTypes = [
            ...Object.values(WeaponTypes),
            ...Object.values(AuxiliaryWeaponTypes),
          ];
          const type = allTypes[Math.floor(Math.random() * allTypes.length)];
          game.powerUps.push(new WeaponPowerUp(enemy.x, enemy.y, type));
        }
      }

      function spawnDroneFormation(size = 3) {
        const baseX = canvas.width + 50;
        const baseY = 50 + Math.random() * (canvas.height - 200);
        const drones = [];

        for (let i = 0; i < size; i++) {
          const offsetY = i * 30;
          drones.push(new DroneEnemy(baseX + i * 30, baseY + offsetY));
        }

        return drones; // ‚úÖ retorna array de DroneEnemy
      }

      function spawnArrowFormationGeneric(
        enemyClass,
        size = 6,
        direction = "<",
        spacingX = 30,
        spacingY = 20
      ) {
        const enemies = [];
        const baseX = canvas.width + 50;

        const groundHeight = canvas.height * 0.1;
        const safetyMargin = 60;

        // Altura total da forma√ß√£o vertical
        const formationHeight = (size - 1) * spacingY;

        // Limites seguros
        const minY = safetyMargin + formationHeight / 2;
        const maxY = canvas.height - groundHeight - formationHeight / 2;
        const centerY = minY + Math.random() * (maxY - minY);

        const half = Math.floor(size / 2);

        for (let i = 0; i < size; i++) {
          const offset = Math.abs(i - half);
          let x, y;

          switch (direction) {
            case "<": // seta para esquerda
              x = baseX + i * spacingX;
              y = centerY + offset * spacingY;
              break;
            case ">": // seta para direita
              x = baseX - i * spacingX;
              y = centerY + offset * spacingY;
              break;
            case "V": // seta para baixo
              x = baseX + offset * spacingX;
              y = centerY + i * spacingY;
              break;
            case "^": // seta para cima
              x = baseX + offset * spacingX;
              y = centerY - i * spacingY;
              break;
          }

          enemies.push(new enemyClass(x, y));
        }

        return enemies;
      }

      class DamageText {
        constructor(x, y, text, color = "yellow") {
          this.x = x;
          this.y = y;
          this.text = text;
          this.color = color;
          this.alpha = 1;
          this.lifetime = 60;
        }

        draw() {
          ctx.globalAlpha = this.alpha;
          ctx.fillStyle = this.color;
          ctx.font = "16px Arial";
          ctx.fillText(this.text, this.x, this.y);
          ctx.globalAlpha = 1.0;
        }

        update() {
          this.y -= 0.5;
          this.alpha -= 1 / this.lifetime;
        }

        isAlive() {
          return this.alpha > 0;
        }
      }

      // Ajustar inimigos para ter vida e barra de vida
      function addHealthToEnemy(cls, baseHealth = 1) {
        return class extends cls {
          constructor(...args) {
            super(...args);
            this.maxHealth = baseHealth;
            this.health = baseHealth;
          }

          draw() {
            super.draw();
            ctx.fillStyle = "gray";
            ctx.fillRect(this.x, this.y - 6, this.width, 5);
            ctx.fillStyle = "lime";
            ctx.fillRect(
              this.x,
              this.y - 6,
              this.width * (this.health / this.maxHealth),
              5
            );
            ctx.strokeStyle = "black";
            ctx.strokeRect(this.x, this.y - 6, this.width, 5);
          }

          takeDamage(amount = 1) {
            this.health -= amount;
            return this.health <= 0;
          }
        };
      }

      BomberEnemy = addHealthToEnemy(BomberEnemy, 3 );
      SniperEnemy = addHealthToEnemy(SniperEnemy, 4);
      DiveEnemy = addHealthToEnemy(DiveEnemy, 2);
      ShieldedEnemy = class extends addHealthToEnemy(ShieldedEnemy, 10) {
        takeDamage(amount = 1) {
          if (this.shielded) {
            this.shielded = false;
            game.damageTexts.push(
              new DamageText(this.x, this.y, "Shield Down", "cyan")
            );
            return false;
          } else {
            return super.takeDamage(amount);
          }
        }
      };
      Tank = addHealthToEnemy(Tank, 5);
      DroneEnemy = addHealthToEnemy(DroneEnemy, 1);


      const waves = [
            () => spawnArrowFormationGeneric(Enemy, 5),
            () => spawnDroneFormation(6),
            () => game.enemies.push(new MiniBoss(canvas.width + 100, 200)),
            () => spawnArrowFormationGeneric(SniperEnemy, 7),
            () => {
                spawnArrowFormationGeneric(Enemy, 3);
                spawnArrowFormationGeneric(DroneEnemy, 6);
            },
            () => game.enemies.push(new MiniBoss(canvas.width + 100, 250)),
            ];

            let currentWave = 0;
            let waveCountdown = 180; // 3 segundos
            let showingWaveText = false;
            let waveTextTimer = 60;


      function novoInimigoAleatorio() {
        const tipo = Math.random();
        const x = canvas.width + Math.random() * 400;

        const groundHeight = canvas.height * 0.1;
        const yMax = canvas.height - groundHeight - 50;
        const y = Math.random() * yMax;

        if (tipo < 0.2) return [new BomberEnemy(x, y)];
        if (tipo < 0.4)
          return spawnArrowFormationGeneric(
            SniperEnemy,
            Math.floor(Math.random() * 1) + 3,
            ">"
          );
        if (tipo < 0.6)
          return spawnArrowFormationGeneric(
            ShieldedEnemy,
            Math.floor(Math.random() * 3) + 3,
            "<"
          );
        if (tipo < 0.8)
          return spawnArrowFormationGeneric(
            DiveEnemy,
            Math.floor(Math.random() * 3) + 3,
            "^"
          );

        // 15% de chance de Stealth (ainda ser√° implementado se quiser)
        // if (tipo < 0.95) return nessw StealthEnemy(x, y);

        if (tipo < 0.95) {
          return spawnArrowFormationGeneric(
            DroneEnemy,
            Math.floor(Math.random() * 12) + 12,
            "^"
          );
        }

        return null;
      }

      function isOverlapping(a, b, padding = 75) {
        return (
          a.x < b.x + b.width + padding &&
          a.x + a.width + padding > b.x &&
          a.y < b.y + b.height + padding &&
          a.y + a.height + padding > b.y
        );
      }
      function spawnWithDistance(factory, existingList, maxAttempts = 15) {
        let attempts = 0;
        while (attempts < maxAttempts) {
          const result = factory();
          if (!result) return null;

          const newEnemies = Array.isArray(result) ? result : [result];

          const hasOverlap = newEnemies.some((newEnemy) =>
            existingList.some((existing) => isOverlapping(newEnemy, existing))
          );

          if (!hasOverlap) return newEnemies;
          attempts++;
        }

        return factory();
      }

      const game = {
        player: new Player(),
        projectiles: [],
        enemyProjectiles: [],
        enemies: [],
        tanks: [],
        powerUps: [],
        grassXs: [],
        score: 0,
        fps: 60,
        lastFrameTime: 0,
        gameOver: false,
        gameOverEventSent: false,
        damageTexts: [],
        miniBoss: null,
        bossTimer: 2500,
        bossActive: false,
        particles: [],

        init() {
          this.reset();
          this.loop(0);
        },

        reset() {
          this.player = new Player();
          this.projectiles = [];
          this.enemyProjectiles = [];
          this.powerUps = [];
          this.enemies = [];
          this.tanks = [];

          for (let i = 0; i < 3; i++) {
            const result = spawnWithDistance(
              () => new Tank(canvas.width + i * 400),
              [...this.enemies, ...this.tanks]
            );
            if (result) {
              const tanks = Array.isArray(result) ? result : [result];
              this.tanks.push(...tanks);
            }
          }

          this.grassXs = Array.from(
            { length: Math.ceil(canvas.width / 20) + 2 },
            (_, i) => i * 20
          );
          this.score = 0;
          this.gameOver = false;
          this.gameOverEventSent = false;
          this.damageTexts = [];
        },

        update() {
          if (this.gameOver) return;
          this.player.update();
          game.player.targetX = null;
          game.player.targetY = null;
          this.damageTexts.forEach((dt) => dt.update());
          this.damageTexts = this.damageTexts.filter((dt) => dt.isAlive());

          game.projectiles = game.projectiles.filter((p) => !p.dead);
          game.particles = game.particles.filter((p) => !p.dead);
          game.particles.forEach((p) => p.update());

          this.projectiles.forEach((p) => p.update());
          this.projectiles = this.projectiles.filter((p) => !p.dead);
          this.projectiles = this.projectiles.filter(
            (p) =>
              p.x < canvas.width && p.y + p.height > 0 && p.y < canvas.height
          );

          this.enemyProjectiles.forEach((p) => p.update());
          this.enemyProjectiles = this.enemyProjectiles.filter(
            (p) =>
              p.x + p.width > 0 && p.y + p.height > 0 && p.y < canvas.height
          );



          // Checa se acabou a wave
        // Sistema de Waves (com prote√ß√£o)
        // if (!showingWaveText && currentWave < waves.length) {
        // // S√≥ conta se n√£o h√° inimigos vivos
        // if (game.enemies.length === 0) {
        //     waveCountdown--;

        //     if (waveCountdown <= 0) {
        //     const waveFn = waves[currentWave];
        //     if (typeof waveFn === "function") {
        //         const result = waveFn();
        //         if (Array.isArray(result)) game.enemies.push(...result);
        //     }
        //     currentWave++;
        //     showingWaveText = true;
        //     waveTextTimer = 60;
        //     waveCountdown = 180;
        //     }
        // }
        // }

           this.enemies.forEach((e) => e.update());
        //   console.log(this.enemies.length);
          if (
            this.enemies.length < 7 + this.score / 100 &&
            Math.random() < 0.005 &&
            !this.bossActive
          ) {
            const result = spawnWithDistance(
              () => novoInimigoAleatorio(),
              this.enemies
            );
            if (result) {
              const newEnemies = Array.isArray(result) ? result : [result];
              this.enemies.push(...newEnemies); // ‚úÖ garante que sempre s√£o elementos individuais
            }
          }
          this.enemies = this.enemies.filter(
            (e) =>
              e.x + e.width > 0 && e.y + e.height > 0 && e.y < canvas.height
          );

          this.tanks.forEach((t) => t.update());

          if (
            this.tanks.length < 3 &&
            Math.random() < 0.005 &&
            !this.bossActive
          ) {
            const result = spawnWithDistance(
              () => new Tank(canvas.width + Math.random() * 400),
              this.tanks
            );
            if (result) {
              const tanks = Array.isArray(result) ? result : [result];
              this.tanks.push(...tanks);
            }
          }
          this.tanks = this.tanks.filter((t) => t.x + t.width > 0);

          this.powerUps.forEach((p) => p.update());
          this.powerUps = this.powerUps.filter((p) => p.x + p.width > 0);

          this.projectiles.forEach((p, pi) => {
            this.enemies.forEach((e, ei) => {
              const hit =
                p.x < e.x + e.width &&
                p.x + p.width > e.x &&
                p.y < e.y + e.height &&
                p.y + p.height > e.y;
              if (hit) {
                HitEffectManager.spawnEffect(p.x, p.y, e.hitEffect);

                if (e.takeDamage && e.takeDamage(p.damage)) {
                  this.enemies.splice(ei, 1);
                  // const newEnemy = novoInimigoAleatorio();
                  // if (newEnemy) {
                  //     const list = Array.isArray(newEnemy) ? newEnemy : [newEnemy];
                  //     this.enemies.push(...list); // ‚úÖ garante que s√≥ elementos individuais entram
                  // }
                  // dropOnEnemyDeath(e); // <<<<< üéØ dropa algo aqui!
                  // 15% de chance de soltar drop
                  if (Math.random() < 0.75) {
                    const dropKeys = Object.keys(DropTypes);
                    const randomKey =
                      dropKeys[Math.floor(Math.random() * dropKeys.length)];
                    const dropType = DropTypes[randomKey];

                    this.powerUps.push(new DropInstance(e.x, e.y, dropType));
                  }

                  this.score++;
                }
                this.projectiles.splice(pi, 1);
                this.damageTexts.push(
                  new DamageText(e.x, e.y, "-" + p.damage, "orange")
                );
              }
            });

            this.tanks.forEach((t, ti) => {
              const hit =
                p.x < t.x + t.width &&
                p.x + p.width > t.x &&
                p.y < t.y + t.height &&
                p.y + p.height > t.y;
              if (hit) {
                for (let i = 0; i < 6; i++) {
                  HitEffectManager.spawnEffect(t.x, t.y, t.hitEffect);
                }
                if (t.takeDamage && t.takeDamage(p.damage)) {
                  this.tanks.splice(ti, 1);
                  // this.tanks.push(new Tank(canvas.width + Math.random() * 400));
                  this.score++;
                }
                this.projectiles.splice(pi, 1);
                this.damageTexts.push(
                  new DamageText(t.x, t.y, "-" + p.damage, "orange")
                );
              }
            });
          });

          for (let p of this.enemyProjectiles) {
            const hit =
              p.x < this.player.x + this.player.width &&
              p.x + p.width > this.player.x &&
              p.y < this.player.y + this.player.height &&
              p.y + p.height > this.player.y;
            if (hit && !this.player.invincible) {
              this.player.health--;
              this.player.invincibilityTimer = 180;
              this.damageTexts.push(
                new DamageText(
                  this.player.x,
                  this.player.y,
                  "-" + p.damage,
                  "red"
                )
              );
              this.enemyProjectiles = this.enemyProjectiles.filter(
                (ep) => ep !== p
              );
              if (this.player.health <= 0) {
                this.gameOver = true;
                setTimeout(() => this.reset(), 2000);
              }
              return;
            }
          }

          [
            ...this.enemies,
            ...this.tanks,
            ...(this.miniBoss ? [this.miniBoss] : []),
          ].forEach((e) => {
            const hit =
              this.player.x < e.x + e.width &&
              this.player.x + this.player.width > e.x &&
              this.player.y < e.y + e.height &&
              this.player.y + this.player.height > e.y;
            if (hit && !this.player.invincible) {
              this.player.health--;
              this.player.invincibilityTimer = 180;
              this.damageTexts.push(
                new DamageText(this.player.x, this.player.y, "-1", "red")
              );
              if (this.player.health <= 0) {
                this.gameOver = true;
                setTimeout(() => this.reset(), 2000);
              }
              return;
            }
          });

          if (Math.random() < 0.002) {
            this.powerUps.push(
              new PowerUp(canvas.width, Math.random() * (canvas.height * 0.8))
            );
          }

          if (Math.random() < 0.002) {
            const allTypes = [
              ...Object.values(WeaponTypes),
              ...Object.values(AuxiliaryWeaponTypes),
            ];
            const type = allTypes[Math.floor(Math.random() * allTypes.length)];
            this.powerUps.push(
              new WeaponPowerUp(
                canvas.width,
                Math.random() * (canvas.height * 0.8),
                type
              )
            );
          }

          for (let p of this.powerUps) {
            const collected =
              this.player.x < p.x + p.width &&
              this.player.x + this.player.width > p.x &&
              this.player.y < p.y + p.height &&
              this.player.y + this.player.height > p.y;
            if (collected) {
              this.powerUps = this.powerUps.filter((po) => po !== p);
              if (p instanceof WeaponPowerUp) {
                p.apply(this.player); // Troca a arma
                this.damageTexts.push(
                  new DamageText(p.x, p.y, p.weaponType.name, "blue")
                );
              } else if (p instanceof DropInstance) {
                p.apply(this.player); // Executa efeito do drop
              } else if (p instanceof PowerUp) {
                if (this.player.health < this.player.maxHealth) {
                  this.player.health++;
                  this.damageTexts.push(
                    new DamageText(p.x, p.y, "+1", "green")
                  );
                }
              }
            }
          }

          // mini-chefe
          if (!this.miniBoss && this.score >= 25 && this.bossTimer <= 0) {
            this.miniBoss = new MiniBoss(
              canvas.width + 50,
              canvas.height / 2 - 40
            );
            this.enemies = []; // limpa inimigos normais para dar espa√ßo
            this.bossActive = true;
          } else if (!this.miniBoss) {
            this.bossTimer--;
          }

          if (this.miniBoss) {
            this.miniBoss.update();
            if (this.miniBoss?.dead) {
              this.miniBoss = null;
              this.bossTimer = 2500;
              this.bossActive = false;
            }
          }

          if (this.miniBoss) {
            this.projectiles.forEach((p, pi) => {
              const b = this.miniBoss;
              const hit =
                p.x < b.x + b.width &&
                p.x + p.width > b.x &&
                p.y < b.y + b.height &&
                p.y + p.height > b.y;
              if (hit) {
                HitEffectManager.spawnEffect(p.x, p.y, b.hitEffect, 1.5);
                b.takeDamage(p.damage);
                this.projectiles.splice(pi, 1);
                this.damageTexts.push(
                  new DamageText(b.x, b.y, "-" + p.damage, "orange")
                );
              }
            });
          }

          if (this.player.airborne || controlMode === CONTROLSMODES.PLANE) {
            this.grassXs = this.grassXs.map((x) => {
              x -= 1;
              if (x < -20) x = canvas.width;
              return x;
            });
          }
        },

        draw() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          this.drawBackground();
          this.player.draw();
          this.projectiles.forEach((p) => p.draw());
          this.enemyProjectiles.forEach((p) => p.draw());
          this.enemies.forEach((e) => e.draw());
          this.tanks.forEach((t) => t.draw());
          this.powerUps.forEach((p) => p.draw());
          this.damageTexts.forEach((dt) => dt.draw());

          ctx.fillStyle = "black";
          ctx.font = "12px Arial";
          ctx.fillText("Score: " + this.score, 20, 30);
          ctx.fillText(
            "Weapon: " +
              this.player.primaryWeapon.name +
              " (Lv" +
              this.player.primaryWeapon.level +
              ")",
            20,
            60
          );

          // Se quiser exibir tamb√©m as auxiliares:
          const auxNames = 
            this.player.auxiliaryWeapons
            ?.map((w) => `${w.name} (Lv${w.level || 1})`)
            .join(", ");
          if (auxNames) {
            ctx.font = "12px Arial";
            ctx.fillText("Aux: " + auxNames, 20, 85);
          }

          ctx.fillStyle = "black";
          ctx.font = "14px Arial";
          ctx.fillText(
            "Enemies: " + this.enemies.length,
            canvas.width - 150,
            30
          );
          ctx.fillText(
            "Projectiles: " + this.projectiles.length,
            canvas.width - 150,
            50
          );
          ctx.fillText("FPS: " + this.fps, canvas.width - 150, 70);
          ctx.fillText(
            "Damage: " + this.player.primaryWeapon.damage,
            canvas.width - 150,
            90
          );
          ctx.fillText(
            "Cooldown: " + this.player.primaryWeapon.cooldown,
            canvas.width - 150,
            110
          );


          if (showingWaveText) {
        ctx.fillStyle = "white";
        ctx.font = "28px monospace";
        ctx.textAlign = "center";
        ctx.fillText(`Wave ${currentWave}`, canvas.width / 2, 80);
        waveTextTimer--;
        if (waveTextTimer <= 0) {
            showingWaveText = false;
        }
        }

          if (this.miniBoss) this.miniBoss.draw();
          game.particles.forEach((p) => p.draw());
          if (!this.player.airborne && !this.gameOver) {
            ctx.font = "16px Arial";
            ctx.fillText("Pressione espa√ßo para voar", 20, 80);
          }

          if (this.gameOver) {
            ctx.fillStyle = "red";
            ctx.font = "20px Arial";
            // Envia evento para Google Tag Manager apenas uma vez
            if (!this.gameOverEventSent) {
              window.dataLayer = window.dataLayer || [];
              window.dataLayer.push({
                'event': 'game_over',
                'event_category': 'game',
                'event_label': 'helicopter_shooter',
                'game_score': this.score
              });
              this.gameOverEventSent = true;
            }
            ctx.fillText(
              "üí• GAME OVER üí•",
              canvas.width / 2 -  85,
              canvas.height / 2
            );
          }
        },

        drawBackground() {
          const groundY = canvas.height - canvas.height * 0.1;
          const grassY = groundY - 20;
          ctx.fillStyle = "#824f2b";
          ctx.fillRect(0, groundY, canvas.width, canvas.height * 0.1);
          for (let x of this.grassXs) {
            ctx.drawImage(IMAGES.grass, x, grassY, 20, 20);
          }
        },

        loop(timestamp) {
          const delta = timestamp - this.lastFrameTime;
          if (delta >= 500 / this.fps) {
            this.update();
            this.draw();
            this.lastFrameTime = timestamp;
          }
          requestAnimationFrame((ts) => this.loop(ts));
        },
      };

      loadImages(ASSETS, () => game.init());
    </script>
  </body>
</html>
