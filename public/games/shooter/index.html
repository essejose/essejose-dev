<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Helicopter Shooter - Jogo de A√ß√£o HTML5 | Essejose</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Jogue Helicopter Shooter online gr√°tis! Controle um helic√≥ptero de combate, derrote inimigos e conquiste a maior pontua√ß√£o. Jogo HTML5 responsivo para desktop e mobile.">
    <meta name="keywords" content="Helicopter Shooter, Game, HTML5, Canvas, JavaScript, jogo online, helic√≥ptero, a√ß√£o, gr√°tis, browser game">
    <meta name="author" content="Essejose">
    <meta name="robots" content="index, follow">
    <meta name="googlebot" content="index, follow">
    <meta name="google" content="notranslate">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://essejose.dev/games/shooter">
    <meta property="og:title" content="Helicopter Shooter - Jogo de A√ß√£o HTML5">
    <meta property="og:description" content="Controle um helic√≥ptero de combate, derrote inimigos e conquiste a maior pontua√ß√£o! Jogue gr√°tis no seu navegador.">
    <meta property="og:image" content="https://essejose.dev/games/shooter/images/poster.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Essejose Dev">
    <meta property="og:locale" content="pt_BR">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://essejose.dev/games/shooter/index.html">
    <meta name="twitter:title" content="Helicopter Shooter - Jogo de A√ß√£o HTML5">
    <meta name="twitter:description" content="Controle um helic√≥ptero de combate, derrote inimigos e conquiste a maior pontua√ß√£o! Jogue gr√°tis no seu navegador.">
    <meta name="twitter:image" content="https://essejose.dev/games/shooter/images/poster.jpg">
    <meta name="twitter:creator" content="@essejose">
    
    <link rel="canonical" href="https://essejose.dev/games/shooter/index.html">
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-W6NSHMJS');</script>
    <!-- End Google Tag Manager -->
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
        background: #cceeff;
      }
      
      /* Bot√£o flutuante da loja */
      #shopButton {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 70px;
        height: 70px;
        border-radius: 50%;
        background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
        border: 4px solid #fff;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), 0 0 20px rgba(255, 215, 0, 0.5);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 35px;
        transition: transform 0.2s, box-shadow 0.2s;
        z-index: 1000;
        user-select: none;
      }
      
      #shopButton:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), 0 0 30px rgba(255, 215, 0, 0.7);
      }
      
      #shopButton:active {
        transform: scale(0.95);
      }
      
      /* Modal da loja */
      #shopModal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 2000;
      }
      
      #shopModal.active {
        display: flex;
      }
      
      #shopContent {
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        border-radius: 20px;
        padding: 30px;
        max-width: 90%;
        max-height: 80%;
        overflow-y: auto;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        border: 3px solid #FFD700;
        position: relative;
      }
      
      #shopContent h2 {
        color: #FFD700;
        text-align: center;
        margin-top: 0;
        font-size: 32px;
        text-shadow: 0 2px 10px rgba(255, 215, 0, 0.5);
      }
      
      #closeShop {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 40px;
        height: 40px;
        background: #ff4444;
        border: none;
        border-radius: 50%;
        color: white;
        font-size: 24px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .shopSection {
        margin-bottom: 30px;
      }
      
      .shopSection h3 {
        color: #00CED1;
        border-bottom: 2px solid #00CED1;
        padding-bottom: 10px;
        margin-bottom: 15px;
      }
      
      .shopItem {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border: 2px solid transparent;
        transition: all 0.3s;
      }
      
      .shopItem:hover {
        border-color: #FFD700;
        background: rgba(255, 215, 0, 0.1);
      }
      
      .shopItem.owned {
        opacity: 0.6;
        border-color: #4CAF50;
      }
      
      .itemInfo {
        flex: 1;
        color: white;
      }
      
      .itemName {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 5px;
      }
      
      .itemDesc {
        font-size: 14px;
        color: #aaa;
      }
      
      .itemPrice {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      
      .buyButton {
        background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        border: none;
        color: white;
        padding: 10px 20px;
        border-radius: 10px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
      }
      
      .buyButton:hover {
        transform: scale(1.05);
      }
      
      .buyButton:disabled {
        background: #666;
        cursor: not-allowed;
        transform: none;
      }
      
      /* Abas da loja */
      .shopTabs {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        border-bottom: 2px solid #FFD700;
      }
      
      .shopTab {
        flex: 1;
        padding: 12px;
        background: rgba(255, 255, 255, 0.1);
        border: none;
        border-bottom: 3px solid transparent;
        color: #aaa;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s;
      }
      
      .shopTab:hover {
        background: rgba(255, 215, 0, 0.1);
        color: white;
      }
      
      .shopTab.active {
        background: rgba(255, 215, 0, 0.2);
        border-bottom-color: #FFD700;
        color: #FFD700;
      }
      
      .shopTabContent {
        display: none;
      }
      
      .shopTabContent.active {
        display: block;
      }
      
      .upgradeItem {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 10px;
        border: 2px solid transparent;
        transition: all 0.3s;
      }
      
      .upgradeItem:hover {
        border-color: #00CED1;
        background: rgba(0, 206, 209, 0.1);
      }
      
      .upgradeItem.maxed {
        opacity: 0.6;
        border-color: #FFD700;
      }
      
      .upgradeHeader {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      
      .upgradeTitle {
        font-size: 18px;
        font-weight: bold;
        color: white;
      }
      
      .upgradeLevel {
        background: rgba(255, 215, 0, 0.2);
        padding: 5px 15px;
        border-radius: 15px;
        color: #FFD700;
        font-weight: bold;
      }
      
      .upgradeDesc {
        color: #aaa;
        font-size: 14px;
        margin-bottom: 10px;
      }
      
      .upgradeEffect {
        color: #00ff00;
        font-size: 14px;
        font-weight: bold;
        margin-bottom: 10px;
      }
      
      .upgradeFooter {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      @media (max-width: 600px) {
        #shopContent {
          padding: 20px;
          max-width: 95%;
        }
        
        #shopContent h2 {
          font-size: 24px;
        }
        
        .itemName {
          font-size: 16px;
        }
        
        .itemDesc {
          font-size: 12px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-W6NSHMJS"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <canvas id="game"></canvas>
    
    <!-- Bot√£o flutuante da loja -->
    <div id="shopButton">üí∞</div>
    
    <!-- Modal da loja -->
    <div id="shopModal">
      <div id="shopContent">
        <button id="closeShop">‚úï</button>
        <h2>üè™ LOJA</h2>
        <div style="text-align: center; color: #FFD700; font-size: 20px; margin-bottom: 20px;">
          Suas Moedas: <span id="shopCoins">0</span> ‚≠ê
        </div>
        
        <!-- Abas da loja -->
        <div class="shopTabs">
          <button class="shopTab active" data-tab="weapons">‚öîÔ∏è ARMAS</button>
          <button class="shopTab" data-tab="upgrades">‚¨ÜÔ∏è UPGRADES</button>
        </div>
        
        <!-- Conte√∫do: Armas -->
        <div id="weaponsTab" class="shopTabContent active">
          <div class="shopSection">
            <h3>‚öîÔ∏è Armas Prim√°rias (Substitui a atual)</h3>
            <div id="primaryWeapons"></div>
          </div>
          
          <div class="shopSection">
            <h3>üéØ Armas Auxiliares (At√© 3 slots)</h3>
            <div style="color: #aaa; margin-bottom: 10px; font-size: 14px;">
              Slots usados: <span id="auxSlots">0/3</span>
            </div>
            <div id="auxiliaryWeapons"></div>
          </div>
        </div>
        
        <!-- Conte√∫do: Upgrades -->
        <div id="upgradesTab" class="shopTabContent">
          <div class="shopSection">
            <h3>üöÅ UPGRADES PERMANENTES</h3>
            <div id="upgradesList"></div>
          </div>
        </div>
      </div>
    </div>
    
    <script>
      const canvas = document.getElementById("game");
      canvas.addEventListener("touchstart", handleTouch);
      canvas.addEventListener("touchmove", handleTouch);

      const ctx = canvas.getContext("2d");
      function handleTouch(e) {
        e.preventDefault(); // evita o scroll em dispositivos m√≥veis

        const touch = e.touches[0]; // usa o primeiro toque
        const rect = canvas.getBoundingClientRect();
        const touchX = touch.clientX - rect.left;
        const touchY = touch.clientY - rect.top;

        // Define o alvo para movimento suave
        game.player.targetX = touchX - game.player.width / 2;
        game.player.targetY = touchY - game.player.height / 2;
      }
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Atualiza escala das camadas de parallax quando redimensionar
        // Usa window.game para evitar erro de inicializa√ß√£o
        try {
          if (window.game && window.game.parallaxLayers) {
            window.game.parallaxLayers.forEach(layer => layer.updateScale());
          }
        } catch (e) {
          // Ignora erro na primeira chamada antes do game ser criado
        }
      }
      
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      const ASSETS = {
        helicopter: "./images/player.png",
        inimigo1: "./images/inimigos/inimigo1.png",
        grass: "https://placehold.co/20x20/88cc88/000?text=G",
        health: "https://placehold.co/20x20/ff66cc/000?text=H",
        parallax1: "./images/parallax-2/6.png",
        parallax2: "./images/parallax-2/5.png",
        parallax3: "./images/parallax-2/4.png",
        parallax4: "./images/parallax-2/3.png",
        parallax5: "./images/parallax-2/2.png",
        parallax6: "./images/parallax-2/1.png",
      };

      const IMAGES = {};
      const CONTROLSMODES = {
        HELICOPTER: "helicopter",
        PLANE: "plane",
      };
      let keys = {};
      let controlMode = CONTROLSMODES.PLANE;
      document.addEventListener("keydown", (e) => {
        keys[e.code] = true;
        if (e.code === "KeyM") {
          controlMode =
            controlMode === CONTROLSMODES.HELICOPTER
              ? CONTROLSMODES.PLANE
              : CONTROLSMODES.HELICOPTER;
        }
        // Ativa/desativa modo debug com tecla K
        if (e.code === "KeyK") {
          game.debug = !game.debug;
          console.log("Debug mode:", game.debug ? "ON" : "OFF");
        }
      });

      document.addEventListener("keydown", (e) => (keys[e.code] = true));
      document.addEventListener("keyup", (e) => (keys[e.code] = false));

      function loadImages(sources, callback) {
        let loaded = 0;
        const total = Object.keys(sources).length;
        for (const key in sources) {
          IMAGES[key] = new Image();
          IMAGES[key].src = sources[key];
          IMAGES[key].onload = () => {
            loaded++;
            if (loaded === total) callback();
          };
        }
      }

      // Classe para gerenciar camadas de parallax
      class ParallaxLayer {
        constructor(image, speed, y = 0) {
          this.image = image;
          this.speed = speed;
          this.y = y;
          this.x1 = 0;
          this.x2 = 0;
          
          // Calcula escala para preencher a altura da tela
          this.updateScale();
        }

        updateScale() {
          if (!this.image || !this.image.width) return;
          
          // Escala baseada na altura da tela
          this.scaleY = canvas.height / this.image.height;
          this.scaleX = this.scaleY; // Mant√©m propor√ß√£o
          
          // Largura escalada da imagem
          this.scaledWidth = this.image.width * this.scaleX;
          this.scaledHeight = canvas.height;
          
          // Posiciona a segunda imagem logo ap√≥s a primeira
          this.x2 = this.scaledWidth;
        }

        update() {
          // Move as duas imagens
          this.x1 -= this.speed;
          this.x2 -= this.speed;

          // Quando a primeira sai completamente da tela, reposiciona ap√≥s a segunda
          if (this.x1 + this.scaledWidth <= 0) {
            this.x1 = this.x2 + this.scaledWidth;
          }

          // Quando a segunda sai completamente da tela, reposiciona ap√≥s a primeira
          if (this.x2 + this.scaledWidth <= 0) {
            this.x2 = this.x1 + this.scaledWidth;
          }
        }

        draw(ctx) {
          if (!this.image || !this.image.complete) return;
          
          // Desenha as duas imagens lado a lado para criar loop infinito
          ctx.drawImage(
            this.image,
            this.x1,
            this.y,
            this.scaledWidth,
            this.scaledHeight
          );
          
          ctx.drawImage(
            this.image,
            this.x2,
            this.y,
            this.scaledWidth,
            this.scaledHeight
          );
        }

        reset() {
          this.updateScale();
          this.x1 = 0;
          this.x2 = this.scaledWidth;
        }
      }

      // Sistema de Combo
      class ComboSystem {
        constructor() {
          this.combo = 0;
          this.comboTimer = 0;
          this.comboTimeout = 180; // 3 segundos (60 FPS)
          this.multiplier = 1;
          this.maxCombo = 0; // Recorde de combo
          this.pulseScale = 1; // Para anima√ß√£o de pulso
        }

        addKill() {
          this.combo++;
          this.comboTimer = this.comboTimeout;
          
          // Atualiza multiplicador (aumenta 10% a cada kill)
          this.multiplier = 1 + (this.combo * 0.1);
          
          // Atualiza recorde
          if (this.combo > this.maxCombo) {
            this.maxCombo = this.combo;
          }
          
          // Efeito de pulso
          this.pulseScale = 1.5;
          
          // Mensagens especiais em marcos
          if (this.combo === 5) {
            game.damageTexts.push(new DamageText(canvas.width/2, 100, "üî• COMBO x5!", "orange"));
          } else if (this.combo === 10) {
            game.damageTexts.push(new DamageText(canvas.width/2, 100, "‚ö° COMBO x10!", "yellow"));
          } else if (this.combo === 20) {
            game.damageTexts.push(new DamageText(canvas.width/2, 100, "üí• COMBO x20!", "red"));
          } else if (this.combo === 50) {
            game.damageTexts.push(new DamageText(canvas.width/2, 100, "üåü LEGENDARY!", "gold"));
          } else if (this.combo % 10 === 0 && this.combo > 20) {
            game.damageTexts.push(new DamageText(canvas.width/2, 100, `üí´ COMBO x${this.combo}!`, "gold"));
          }
        }

        reset() {
          this.combo = 0;
          this.multiplier = 1;
          this.comboTimer = 0;
        }

        update() {
          // Reduz o timer do combo
          if (this.comboTimer > 0) {
            this.comboTimer--;
          } else if (this.combo > 0) {
            // Combo perdido
            if (this.combo >= 5) {
              game.damageTexts.push(new DamageText(canvas.width/2, 150, "COMBO PERDIDO!", "gray"));
            }
            this.reset();
          }
          
          // Anima o pulso
          if (this.pulseScale > 1) {
            this.pulseScale -= 0.05;
            if (this.pulseScale < 1) this.pulseScale = 1;
          }
        }

        getScoreMultiplier() {
          return Math.floor(this.multiplier * 10) / 10; // Arredonda para 1 casa decimal
        }

        draw(ctx) {
          if (this.combo === 0) return;
          
          // Posi√ß√£o do combo
          const x = canvas.width - 180;
          const y = 150;
          
          // Cor baseada no combo
          let color = 'white';
          if (this.combo >= 50) color = 'gold';
          else if (this.combo >= 20) color = '#ff6b6b';
          else if (this.combo >= 10) color = '#ffd93d';
          else if (this.combo >= 5) color = 'orange';
          
          // Desenha "COMBO"
          ctx.save();
          ctx.translate(x, y);
          ctx.scale(this.pulseScale, this.pulseScale);
          
          ctx.fillStyle = color;
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 3;
          ctx.font = 'bold 20px Arial';
          ctx.strokeText('COMBO', -30, 0);
          ctx.fillText('COMBO', -30, 0);
          
          // Desenha o n√∫mero do combo
          ctx.font = 'bold 48px Arial';
          ctx.strokeText(`x${this.combo}`, -30, 45);
          ctx.fillText(`x${this.combo}`, -30, 45);
          
          ctx.restore();
          
          // Desenha multiplicador
          ctx.fillStyle = 'white';
          ctx.font = '16px Arial';
          ctx.fillText(`Multiplicador: x${this.getScoreMultiplier()}`, x - 30, y + 70);
          
          // Barra de tempo do combo
          const barWidth = 150;
          const barHeight = 8;
          const barX = x - 30;
          const barY = y + 80;
          
          // Fundo da barra
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(barX, barY, barWidth, barHeight);
          
          // Progresso da barra
          const progress = this.comboTimer / this.comboTimeout;
          let barColor = '#4CAF50';
          if (progress < 0.3) barColor = '#ff4444';
          else if (progress < 0.6) barColor = '#ffaa00';
          
          ctx.fillStyle = barColor;
          ctx.fillRect(barX, barY, barWidth * progress, barHeight);
          
          // Borda da barra
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          ctx.strokeRect(barX, barY, barWidth, barHeight);
        }
      }

      // Sistema de Countdown
      class CountdownSystem {
        constructor() {
          this.active = false;
          this.count = 2;
          this.timer = 0;
          this.callback = null;
          this.message = "";
        }

        start(callback, startMessage = "GET READY!") {
          this.active = true;
          this.count = 2;
          this.timer = 60; // 1 segundo por n√∫mero
          this.callback = callback;
          this.message = startMessage;
        }

        update() {
          if (!this.active) return;

          this.timer--;

          if (this.timer <= 0) {
            this.count--;
            
            if (this.count < 0) {
              // Countdown terminou
              this.active = false;
              if (this.callback) {
                this.callback();
              }
            } else {
              this.timer = 60; // Reseta timer para pr√≥ximo n√∫mero
            }
          }
        }

        draw(ctx) {
          if (!this.active) return;

          // Overlay escuro
          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Mensagem superior
          if (this.message) {
            ctx.fillStyle = "#FFD700";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 4;
            ctx.font = "bold 36px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.strokeText(this.message, canvas.width / 2, canvas.height / 2 - 80);
            ctx.fillText(this.message, canvas.width / 2, canvas.height / 2 - 80);
          }

          // N√∫mero do countdown ou READY
          const scale = 1 + (this.timer / 60) * 0.3; // Efeito de pulso
          
          ctx.save();
          ctx.translate(canvas.width / 2, canvas.height / 2);
          ctx.scale(scale, scale);

          if (this.count > 0) {
            // N√∫meros 3, 2, 1
            ctx.fillStyle = "#FF4444";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 6;
            ctx.font = "bold 120px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.strokeText(this.count.toString(), 0, 0);
            ctx.fillText(this.count.toString(), 0, 0);
          } else {
            // READY!
            ctx.fillStyle = "#00FF00";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 6;
            ctx.font = "bold 80px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.strokeText("READY!", 0, 0);
            ctx.fillText("READY!", 0, 0);
          }

          ctx.restore();
        }
      }

      // Sistema de Moedas
      class CoinDrop {
        constructor(x, y, value = 1) {
          this.x = x;
          this.y = y;
          this.value = value; // Valor da moeda (1, 2, 5, 10...)
          this.width = 20;
          this.height = 20;
          this.vx = (Math.random() - 0.5) * 2; // Movimento horizontal aleat√≥rio
          this.vy = -2 - Math.random() * 2; // Pula para cima
          this.gravity = 0.2;
          this.bounce = 0.5;
          this.lifetime = 600; // 10 segundos
          this.collected = false;
          
          // Anima√ß√£o de brilho
          this.pulseTime = 0;
          this.pulseSpeed = 0.1;
        }

        update() {
          // F√≠sica da moeda
          this.vy += this.gravity;
          this.x += this.vx;
          this.y += this.vy;
          
          // Fric√ß√£o
          this.vx *= 0.98;
          
          // Bounce no ch√£o
          const groundY = canvas.height - canvas.height * 0.1 - this.height;
          if (this.y >= groundY) {
            this.y = groundY;
            this.vy *= -this.bounce;
            this.vx *= 0.8;
            
            // Para de quicar se muito lento
            if (Math.abs(this.vy) < 0.5) {
              this.vy = 0;
            }
          }
          
          // Move para esquerda com o cen√°rio
          this.x -= 1;
          
          // Anima√ß√£o
          this.pulseTime += this.pulseSpeed;
          
          // Lifetime
          this.lifetime--;
          
          // Magnetismo - atrai para o player quando pr√≥ximo
          const dx = game.player.x - this.x;
          const dy = game.player.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 100) {
            const pullForce = 0.3;
            this.x += (dx / dist) * pullForce * 10;
            this.y += (dy / dist) * pullForce * 10;
          }
        }

        draw(ctx) {
          // Efeito de pulso
          const scale = 1 + Math.sin(this.pulseTime) * 0.2;
          
          ctx.save();
          ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
          ctx.scale(scale, scale);
          
          // Cor baseada no valor
          let color = '#FFD700'; // Dourado
          if (this.value >= 10) color = '#FF69B4'; // Rosa para valores altos
          else if (this.value >= 5) color = '#00CED1'; // Ciano para valores m√©dios
          
          // Desenha a moeda
          ctx.fillStyle = color;
          ctx.strokeStyle = '#FFA500';
          ctx.lineWidth = 2;
          
          ctx.beginPath();
          ctx.arc(0, 0, this.width / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // S√≠mbolo da moeda
          ctx.fillStyle = '#000';
          ctx.font = 'bold 14px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('‚≠ê', 0, 0);
          
          // Valor (se maior que 1)
          if (this.value > 1) {
            ctx.fillStyle = '#FFF';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.font = 'bold 10px Arial';
            ctx.strokeText(this.value, 0, -8);
            ctx.fillText(this.value, 0, -8);
          }
          
          ctx.restore();
        }

        get dead() {
          return this.lifetime <= 0 || this.x < -50 || this.collected;
        }
      }

      const HitEffectManager = {
        spawnEffect(x, y, type = "spark", intensity = 1) {
          switch (type) {
            case "spark": // Fa√≠sca leve
              for (let i = 0; i < 4 * intensity; i++) {
                game.particles.push(new ExplosionParticle(x, y, "yellow"));
              }
              break;

            case "explosion": // Explos√£o forte
              for (let i = 0; i < 10 * intensity; i++) {
                const color = Math.random() < 0.5 ? "orange" : "red";
                game.particles.push(new ExplosionParticle(x, y, color));
              }
              game.shakeX = 4 * intensity;
              game.shakeY = 3 * intensity;
              break;

            case "laser":
              for (let i = 0; i < 6 * intensity; i++) {
                game.particles.push(new ExplosionParticle(x, y, "cyan"));
              }
              break;

            case "hitPlayer":
              for (let i = 0; i < 4; i++) {
                game.particles.push(new ExplosionParticle(x, y, "white"));
              }
              game.shakeX = 2;
              break;

            default:
              console.warn("Efeito desconhecido:", type);
          }
        },
      };
      const WeaponTypes = {
        BASIC: {
          speed: 8,
          damage: 2,
          color: "red",
          name: "BASIC",
          cooldown: 15,
          isAuxiliary: false,
          hitEffect: "spark",
          wobbleY: 0.8, // üëà pequena varia√ß√£o vertical por frame
        },
        SPREAD: {
          speed: 7,
          damage: 2,
          spread: true,
          color: "orange",
          name: "SPREAD",
          cooldown: 20,
          isAuxiliary: false,
          hitEffect: "spark",
        },
        BURST: {
          speed: 10,
          damage: 2,
          color: "yellow",
          name: "BURST",
          cooldown: 8,
          burst: true,
          burstCount: 3,
          burstDelay: 5,
          isAuxiliary: false,
          hitEffect: "spark",
        },
        LASER: {
          speed: 12,
          damage: 3,
          color: "lime",
          name: "LASER",
          cooldown: 5,
          isAuxiliary: false,
          hitEffect: "laser",
        },
        MISSILE: {
          speed: 6,
          damage: 4,
          color: "blue",
          name: "MISSILE",
          cooldown: 40,
          homing: true,
          isAuxiliary: false,
          hitEffect: "explosion",
        },
      };

      const AuxiliaryWeaponTypes = {
        MISSILE: {
          speed: 7,
          damage: 3,
          color: "blue",
          name: "MISSILE",
          cooldown: 50,
          homing: true,
          isAuxiliary: true,
          hitEffect: "explosion",
        },
        ORBITAL: {
          name: "ORBITAL",
          color: "cyan",
          cooldown: 60,
          speed: 6,
          damage: 2,
          isAuxiliary: true,
          orbit: true,
          hitEffect: "spark",
        },
        MINE: {
          speed: 6,
          damage: 4,
          color: "black",
          name: "MINE",
          cooldown: 80,
          isAuxiliary: true,
          hitEffect: "explosion",
        },
        TURRET: {
          name: "TURRET",
          color: "orange",
          cooldown: 40,
          speed: 8,
          damage: 2,
          isAuxiliary: true,
          turret: true,
          hitEffect: "spark",
        },
        SHIELD: {
          name: "SHIELD",
          color: "purple",
          cooldown: 180,
          damage: 0,
          isAuxiliary: true,
          shield: true,
          hitEffect: "spark",
        },
        BEAM: {
          name: "BEAM",
          color: "#FFD700",
          cooldown: 30,
          speed: 12,
          damage: 1,
          isAuxiliary: true,
          beam: true,
          hitEffect: "spark",
        },
      };

      class ProximityMineProjectile {
        constructor(x, y, damage = 4, radius = 50) {
          this.x = x;
          this.y = y;
          this.damage = damage;
          this.radius = radius;
          this.width = 12;
          this.height = 12;
          this.timer = 300; // 5 segundos
          this.armed = false;
          this.armDelay = 30;
          this.blinkCounter = 0;
        }

        draw() {
          if (this.armed) {
            // Pisca em vermelho e amarelo
            const blink = Math.floor(this.blinkCounter / 10) % 2 === 0;
            ctx.fillStyle = blink ? "red" : "yellow";
          } else {
            ctx.fillStyle = "gray";
          }

          ctx.beginPath();
          ctx.arc(this.x, this.y, this.width / 2, 0, Math.PI * 2);
          ctx.fill();

          // Mostra raio de detec√ß√£o
          if (this.armed) {
            ctx.strokeStyle = "rgba(255,0,0,0.3)";
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
            ctx.stroke();
          }
        }

        update() {
          if (this.armDelay > 0) {
            this.armDelay--;
          } else {
            this.armed = true;
          }

          this.timer--;
          this.blinkCounter++;

          if (!this.armed) return;

          for (let e of game.enemies) {
            const closestX = Math.max(e.x, Math.min(this.x, e.x + e.width));
            const closestY = Math.max(e.y, Math.min(this.y, e.y + e.height));
            const dx = this.x - closestX;
            const dy = this.y - closestY;
            const distSq = dx * dx + dy * dy;

            if (distSq < this.radius * this.radius) {
              this.explode();
              return;
            }
          }

          if (this.timer <= 0) {
            this.explode();
          }
        }

        explode() {
          game.damageTexts.push(new DamageText(this.x, this.y, "üí•", "red"));

          for (let en of game.enemies) {
            const closestX = Math.max(en.x, Math.min(this.x, en.x + en.width));
            const closestY = Math.max(en.y, Math.min(this.y, en.y + en.height));
            const dx = this.x - closestX;
            const dy = this.y - closestY;
            const distSq = dx * dx + dy * dy;

            if (distSq < this.radius * this.radius) {
              if (en.takeDamage) en.takeDamage(this.damage);
            }
          }

          this.dead = true;
          for (let i = 0; i < 15; i++) {
            game.particles.push(
              new ExplosionParticle(
                this.x,
                this.y,
                Math.random() < 0.5 ? "orange" : "gray"
              )
            );
          }
        }
      }

      class ExplosionParticle {
        constructor(x, y, color = "orange") {
          this.x = x;
          this.y = y;
          this.vx = (Math.random() - 0.5) * 4;
          this.vy = (Math.random() - 0.5) * 4;
          this.alpha = 1;
          this.radius = 2 + Math.random() * 2;
          this.color = color;
          this.life = 30 + Math.random() * 20;
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.life--;
          this.alpha = Math.max(0, this.life / 40);
        }

        draw() {
          ctx.globalAlpha = this.alpha;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        get dead() {
          return this.life <= 0;
        }
      }

      class OrbitalDrone {
        constructor(player, angle, weaponInstance) {
          this.player = player;
          this.angle = angle; // em radianos
          this.radius = 50;
          this.weapon = weaponInstance;
          this.cooldown = 0;
        }

        update(index, total) {
          // Orbita baseado em tempo + √≠ndice (para m√∫ltiplos drones)
          const rotationSpeed = 0.02;
          this.angle += rotationSpeed;

          // Calcula a posi√ß√£o em volta do player
          const px = this.player.x + this.player.width / 2;
          const py = this.player.y + this.player.height / 2;
          this.x = px + Math.cos(this.angle) * this.radius;
          this.y = py + Math.sin(this.angle) * this.radius;

          // Tiro autom√°tico
          if (this.cooldown <= 0) {
            const vx = this.weapon.speed;
            const vy = 0;
            game.projectiles.push(new Projectile(this.x, this.y, this.weapon));
            // Aplica redutor de cooldown baseado em upgrades
            const fireRateMultiplier = 1 - (game.upgrades.fireRate * 0.10);
            this.cooldown = this.weapon.cooldown * fireRateMultiplier;
          } else {
            this.cooldown--;
          }
        }

        draw() {
          ctx.fillStyle = this.weapon.color || "cyan";
          ctx.beginPath();
          ctx.arc(this.x, this.y, 6, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      class WeaponInstance {
        constructor(type, level = 1) {
          this.type = type; // referencia ao tipo base (WeaponTypes ou AuxiliaryWeaponTypes)
          this.level = level;
          this.damage = type.damage + (level - 1);
          this.cooldown = Math.max(5, type.cooldown - (level - 1));
          this.cooldownCounter = 0;
          this.spread = type.spread || false;
          this.homing = type.homing || false;
          this.color = type.color;
          this.name = type.name;
          this.speed = type.speed;
        }

        levelUp() {
          this.level++;
          this.damage++;
          this.cooldown = Math.max(5, this.type.cooldown - (this.level - 1));
        }

        readyToShoot() {
          return this.cooldownCounter <= 0;
        }

        updateCooldown(player) {
          let factor = 1;
          if (player?.rapidFireTimer > 0) {
            factor = 2; // 2x mais r√°pido (cooldown reduzido pela metade)
          }

          if (this.cooldownCounter > 0) {
            this.cooldownCounter -= factor;
          }
        }

        resetCooldown() {
          this.cooldownCounter = this.cooldown;
        }
      }

      const DropTypes = {
        LIFE: {
          name: "LIFE",
          color: "green",
          apply(player) {
            if (player.health < player.maxHealth) {
              player.health++;
              game.damageTexts.push(
                new DamageText(player.x, player.y, "+1 HP", "green")
              );
            }
          },
        },
        SHIELD: {
          name: "SHIELD",
          color: "cyan",
          apply(player) {
            player.invincibilityTimer = 240;
            game.damageTexts.push(
              new DamageText(player.x, player.y, "Shield!", "cyan")
            );
          },
        },
        BOMB: {
          name: "BOMB",
          color: "red",
          apply(player) {
            const count = game.enemies.length;
            game.enemies = [];
            game.projectiles = game.projectiles.filter((p) => !p.homing);

            game.damageTexts.push(
              new DamageText(player.x, player.y, `üí£ ${count} enemies`, "red")
            );
          },
        },
        SPEED: {
          name: "SPEED",
          color: "orange",
          apply(player) {
            player.speedBoost = 1.5;
            player.speedBoostTimer = 300;
            game.damageTexts.push(
              new DamageText(player.x, player.y, "Speed!", "orange")
            );
          },
        },
        RAPID: {
          name: "RAPID",
          color: "magenta",
          apply(player) {
            player.rapidFireTimer = 300; // dura 5 segundos (60 FPS)
            game.damageTexts.push(
              new DamageText(player.x, player.y, "Rapid Fire!", "magenta")
            );
          },
        },
      };

      class DropInstance {
        constructor(x, y, dropType) {
          this.x = x;
          this.y = y;
          this.width = 20;
          this.height = 20;
          this.dropType = dropType;
        }

        draw() {
          ctx.fillStyle = this.dropType.color;
          ctx.fillRect(this.x, this.y, this.width, this.height);
          ctx.fillStyle = "black";
          ctx.font = "12px Arial";
          ctx.fillText(this.dropType.name[0], this.x + 6, this.y + 14); // Letra do tipo
        }

        update() {
          this.x -= 2;
        }

        apply(player) {
          this.dropType.apply(player);
        }
      }

      function createWeapon(type, level = 1) {
        const base = WeaponTypes[type];
        return new WeaponInstance(base, level);
      }

      // Adicionar classe PowerUp de arma
      class WeaponPowerUp {
        constructor(x, y, weaponType) {
          this.x = x;
          this.y = y;
          this.width = 20;
          this.height = 20;
          this.weaponType = weaponType;
        }

        draw() {
          ctx.fillStyle = this.weaponType.color;
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        update() {
          this.x -= 2;
        }

        apply(player) {
          const same = player.primaryWeapon.name === this.weaponType.name;

          if (same) {
            player.primaryWeapon.levelUp();
          } else {
            console.log(this.weaponType);
            const isAuxiliary = this.weaponType.isAuxiliary === true;

            if (isAuxiliary) {
              const existing = player.auxiliaryWeapons.find(
                (w) => w.name === this.weaponType.name
              );
              if (existing) {
                existing.levelUp();
              } else if (player.auxiliaryWeapons.length < 5) {
                player.auxiliaryWeapons.push(
                  new WeaponInstance(this.weaponType)
                );
                game.damageTexts.push(
                  new DamageText(this.x, this.y, "New Auxiliary Weapon", "gray")
                );
              }
            } else {
              // Ex: game.damageTexts.push(new DamageText(this.x, this.y, "Incompat√≠vel", "gray"));
            }
          }
        }
      }

      class PowerUp {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.width = 20;
          this.height = 20;
          this.vx = (Math.random() - 0.5) * 2; // Movimento horizontal aleat√≥rio
          this.vy = -3 - Math.random() * 2; // Pula para cima
          this.gravity = 0.2;
          this.bounce = 0.4;
          this.lifetime = 600; // 10 segundos
        }

        draw() {
          ctx.drawImage(IMAGES.health, this.x, this.y, this.width, this.height);
        }

        update() {
          // F√≠sica do power-up
          this.vy += this.gravity;
          this.x += this.vx;
          this.y += this.vy;
          
          // Fric√ß√£o
          this.vx *= 0.98;
          
          // Bounce no ch√£o
          const groundY = canvas.height - canvas.height * 0.1 - this.height;
          if (this.y >= groundY) {
            this.y = groundY;
            this.vy *= -this.bounce;
            this.vx *= 0.8;
            
            // Para de quicar se muito lento
            if (Math.abs(this.vy) < 0.5) {
              this.vy = 0;
            }
          }
          
          // Move para esquerda com o cen√°rio
          this.x -= 1;
          
          // Lifetime
          this.lifetime--;
          
          // Magnetismo - atrai para o player quando pr√≥ximo
          const dx = game.player.x - this.x;
          const dy = game.player.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 100) {
            const pullForce = 0.2;
            this.x += (dx / dist) * pullForce * 10;
            this.y += (dy / dist) * pullForce * 10;
          }
        }
        
        get dead() {
          return this.lifetime <= 0 || this.x < -50;
        }
      }

      class Player {
        constructor() {
          this.x = 100;
          this.y = canvas.height * 0.5;
          this.width = 80;
          this.height = 80;
          this.velocity = 0;
          this.gravity = 0.3;
          this.lift = -0.6;
          this.cooldown = 0;
          this.airborne = true;
          this.maxHealth = 5;
          this.health = this.maxHealth;
          this.invincible = false;
          this.invincibilityTimer = 0;
          this.speed = 8;
          this.rapidFireTimer = 0;
          this.orbitalDrones = [];
          this.shieldActive = false;
          this.shieldTimer = 0;

          // Propriedades para movimento suave no mobile
          this.targetX = null;
          this.targetY = null;
          this.moveSpeed = 0.15; // Velocidade de interpola√ß√£o (0.1 = mais lento, 0.3 = mais r√°pido)

          // Propriedades para inclina√ß√£o (tilt) ao se mover
          this.tiltAngle = 0; // √Çngulo atual de inclina√ß√£o
          this.maxTilt = 0.15; // Inclina√ß√£o m√°xima em radianos (~8 graus)
          this.tiltSpeed = 0.1; // Velocidade de transi√ß√£o da inclina√ß√£o
          this.prevX = this.x; // Posi√ß√£o anterior para calcular movimento
          this.prevY = this.y;

          // Propriedades para anima√ß√£o da h√©lice traseira
          this.propellerAngle = 0;
          this.propellerSpeed = 0.3; // Velocidade de rota√ß√£o da h√©lice
          this.propellerRadius = 8; // Raio da h√©lice

          // Propriedades para anima√ß√£o do rotor principal
          this.mainRotorAngle = 0;
          this.mainRotorSpeed = 0.2; // Velocidade de rota√ß√£o do rotor principal
          this.mainRotorRadius = 30; // Raio do rotor principal

          // Armas - Come√ßa com BASIC e sem auxiliares
          this.primaryWeapon = new WeaponInstance(WeaponTypes.BASIC);
          this.auxiliaryWeapons = []; // Come√ßa vazio, pode ter at√© 3
        }

        draw() {
          // Salva o estado do canvas antes de aplicar rota√ß√£o
          ctx.save();
          
          // Define o ponto de rota√ß√£o no centro do helic√≥ptero
          const centerX = this.x + this.width / 2;
          const centerY = this.y + this.height / 2;
          
          // Move para o centro do helic√≥ptero
          ctx.translate(centerX, centerY);
          
          // Aplica a rota√ß√£o (inclina√ß√£o)
          ctx.rotate(this.tiltAngle);
          
          // Move de volta para desenhar o helic√≥ptero
          ctx.translate(-centerX, -centerY);
          
          // Desenha o helic√≥ptero com transpar√™ncia se invenc√≠vel
          if (
            this.invincible &&
            Math.floor(this.invincibilityTimer / 5) % 2 === 0
          ) {
            ctx.globalAlpha = 0.5;
          }
          ctx.drawImage(
            IMAGES.helicopter,
            this.x,
            this.y,
            this.width,
            this.height
          );
          ctx.globalAlpha = 1.0;

          // Desenha a h√©lice traseira animada
          this.drawPropeller();
          
          // Desenha o rotor principal animado
          this.drawMainRotor();

          // Restaura o estado do canvas (remove a rota√ß√£o)
          ctx.restore();

          // Desenha escudo se ativo
          if (this.shieldActive && this.shieldTimer > 0) {
            const shieldRadius = Math.max(this.width, this.height) / 2 + 15;
            const centerX = this.x + this.width / 2;
            const centerY = this.y + this.height / 2;
            
            // Efeito de pulso
            const pulse = Math.sin(Date.now() / 100) * 3;
            
            ctx.save();
            ctx.strokeStyle = "rgba(138, 43, 226, 0.6)"; // Purple
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.arc(centerX, centerY, shieldRadius + pulse, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
            
            // Barra de tempo do shield
            const shieldBarWidth = 60;
            const shieldBarHeight = 4;
            const shieldBarX = this.x;
            const shieldBarY = this.y - 20;
            const shieldPercent = this.shieldTimer / 180;
            
            ctx.fillStyle = "rgba(138, 43, 226, 0.3)";
            ctx.fillRect(shieldBarX, shieldBarY, shieldBarWidth, shieldBarHeight);
            ctx.fillStyle = "rgba(138, 43, 226, 0.8)";
            ctx.fillRect(shieldBarX, shieldBarY, shieldBarWidth * shieldPercent, shieldBarHeight);
          }

          // Desenha a barra de vida (sem rota√ß√£o)
          const barWidth = 60;
          const barHeight = 8;
          const barX = this.x;
          const barY = this.y - 12;
          ctx.fillStyle = "gray";
          ctx.fillRect(barX, barY, barWidth, barHeight);
          ctx.fillStyle = "limegreen";
          ctx.fillRect(
            barX,
            barY,
            barWidth * (this.health / this.maxHealth),
            barHeight
          );
          ctx.strokeStyle = "black";
          ctx.strokeRect(barX, barY, barWidth, barHeight);

          if (this.orbitalDrones) {
            this.orbitalDrones.forEach((drone) => drone.draw());
          }
        }

        drawPropeller() {
          const centerX = this.x + this.width / 27;
          const centerY = this.y + this.height / 2.7;
          
          // Salva o estado atual do canvas
          ctx.save();
          
          // Move o ponto de rota√ß√£o para o centro do player
          ctx.translate(centerX, centerY);
          
          // Rotaciona baseado no √¢ngulo da h√©lice
          ctx.rotate(this.propellerAngle);
          
          // Desenha as p√°s da h√©lice
          ctx.strokeStyle = "#333";
          ctx.lineWidth = 2;
          
          // P√° 1 (horizontal)
          ctx.beginPath();
          ctx.moveTo(-this.propellerRadius, 0);
          ctx.lineTo(this.propellerRadius, 0);
          ctx.stroke();
          
          // P√° 2 (vertical)
          ctx.beginPath();
          ctx.moveTo(0, -this.propellerRadius);
          ctx.lineTo(0, this.propellerRadius);
          ctx.stroke();
          
          // Desenha o centro da h√©lice
          ctx.fillStyle = "#666";
          ctx.beginPath();
          ctx.arc(0, 0, .5, 0, Math.PI * 2);
          ctx.fill();
          
          // Restaura o estado do canvas
          ctx.restore();
        }

        drawMainRotor() {
          const centerX = this.x + 47;
          const centerY = this.y + 25; // Posiciona acima do helic√≥ptero
          
          // Salva o estado atual do canvas
          ctx.save();
          
          // Move o ponto de rota√ß√£o para o centro do rotor
          ctx.translate(centerX, centerY);
          
          // Calcula a opacidade baseada no √¢ngulo para simular o efeito de "aparecer e sumir" (flicker/blur)
          // A opacidade ir√° oscilar entre 0.3 e 0.8, dando a impress√£o de movimento r√°pido.
          const minOpacity = 0.3;
          const maxOpacity = 0.8;
          const opacity = minOpacity + (maxOpacity - minOpacity) * Math.abs(Math.sin(this.mainRotorAngle * 2)); 
          
          ctx.globalAlpha = opacity; // Aplica a transpar√™ncia

          // Desenha as p√°s do rotor principal como uma linha horizontal fixa
          ctx.strokeStyle = "#444";
          ctx.lineWidth = 4;
          
          // P√° 1 (horizontal) - parte esquerda
          ctx.beginPath();
          ctx.moveTo(-this.mainRotorRadius, 0);
          ctx.lineTo(-2, 0); // Desenha at√© a esquerda do centro
          ctx.stroke();

          // P√° 2 (horizontal) - parte direita
          ctx.beginPath();
          ctx.moveTo(2, 0); // Desenha a partir da direita do centro
          ctx.lineTo(this.mainRotorRadius, 0);
          ctx.stroke();
          
          // Desenha o centro do rotor
          ctx.beginPath();
          ctx.arc(0, 0, 2, 0, Math.PI * 2);
          ctx.fillStyle = "#555";
          ctx.fill();

          ctx.globalAlpha = 1; // Restaura a opacidade global para n√£o afetar outros desenhos
          // Restaura o estado do canvas
          ctx.restore();
        }

        update() {
          // Movimento suave para mobile
          if (this.targetX !== null && this.targetY !== null) {
            const dx = this.targetX - this.x;
            const dy = this.targetY - this.y;
            
            // Interpola√ß√£o suave
            this.x += dx * this.moveSpeed;
            this.y += dy * this.moveSpeed;
            
            // Para quando estiver pr√≥ximo o suficiente do alvo
            if (Math.abs(dx) < 2 && Math.abs(dy) < 2) {
              this.x = this.targetX;
              this.y = this.targetY;
              this.targetX = null;
              this.targetY = null;
            }
          }

          // Atualiza anima√ß√£o da h√©lice traseira
          this.propellerAngle += this.propellerSpeed;
          
          // Atualiza anima√ß√£o do rotor principal
          this.mainRotorAngle += this.mainRotorSpeed;

          // Calcula inclina√ß√£o baseada no movimento horizontal
          const velocityX = this.x - this.prevX;
          const velocityY = this.y - this.prevY;
          
          // Inclina√ß√£o para frente quando movendo para direita
          let targetTilt = 0;
          if (velocityX > 0.5) {
            targetTilt = this.maxTilt; // Inclina para frente
          } else if (velocityX < -0.5) {
            targetTilt = -this.maxTilt * 0.5; // Inclina levemente para tr√°s
          }
          
          // Inclina√ß√£o adicional baseada no movimento vertical
          if (velocityY < -0.5) {
            targetTilt += this.maxTilt * 0.3; // Inclina mais para frente ao subir
          } else if (velocityY > 0.5) {
            targetTilt -= this.maxTilt * 0.3; // Inclina para tr√°s ao descer
          }
          
          // Suaviza a transi√ß√£o do √¢ngulo de inclina√ß√£o
          this.tiltAngle += (targetTilt - this.tiltAngle) * this.tiltSpeed;
          
          // Atualiza posi√ß√£o anterior
          this.prevX = this.x;
          this.prevY = this.y;

          if (controlMode === CONTROLSMODES.HELICOPTER) {
            if (keys["Space"]) {
              this.velocity += this.lift;
            }

            this.velocity += this.gravity;
            this.y += this.velocity;

            const groundY = canvas.height - this.height - canvas.height * 0.1;
            if (this.y >= groundY) {
              this.y = groundY;
              this.velocity = 0;
              this.airborne = false;
            } else {
              this.airborne = true;
            }

            if (this.y < 0) {
              this.y = 0;
              this.velocity = 0;
            }
          } else if (controlMode === CONTROLSMODES.PLANE) {
            const speed = this.speed * (this.speedBoost || 1);
            if (keys["ArrowUp"] || keys["KeyW"]) this.y -= speed;
            if (keys["ArrowDown"] || keys["KeyS"]) this.y += speed;
            if (keys["ArrowLeft"] || keys["KeyA"]) this.x -= speed;
            if (keys["ArrowRight"] || keys["KeyD"]) this.x += speed;

            const groundY = canvas.height - this.height - canvas.height * 0.1;
            if (this.y >= groundY) this.y = groundY;
            if (this.y < 0) this.y = 0;
            if (this.x < 0) this.x = 0;
            if (this.x + this.width > canvas.width)
              this.x = canvas.width - this.width;
          }

          this.primaryWeapon.updateCooldown(this);
          if (this.primaryWeapon.readyToShoot()) {
            this.shoot();
            this.primaryWeapon.resetCooldown();
          }

          this.auxiliaryWeapons.forEach((weapon) => {
            weapon.updateCooldown(this);
            if (weapon.readyToShoot()) {
              this.fireWeapon(weapon);
              weapon.resetCooldown();
            }
          });

          if (this.speedBoostTimer > 0) {
            this.speedBoostTimer--;
            if (this.speedBoostTimer <= 0) {
              this.speedBoost = 1;
            }
          }

          if (this.rapidFireTimer > 0) {
            this.rapidFireTimer--;
          }

          if (this.cooldown > 0) this.cooldown--;
          if (this.invincibilityTimer > 0) {
            this.invincibilityTimer--;
            this.invincible = true;
          } else {
            this.invincible = false;
          }
          
          // Atualiza shield timer
          if (this.shieldTimer > 0) {
            this.shieldTimer--;
            if (this.shieldTimer <= 0) {
              this.shieldActive = false;
            }
          }

          if (!this.orbitalDrones) this.orbitalDrones = [];

          const orbitalWeapons = this.auxiliaryWeapons.filter(
            (w) => w.name === "ORBITAL"
          );

          if (orbitalWeapons.length > 0) {
            const weapon = orbitalWeapons[0];
            const count = Math.min(weapon.level, 4); // at√© 3 drones
            while (this.orbitalDrones.length < count) {
              this.orbitalDrones.push(
                new OrbitalDrone(this, Math.random() * Math.PI * 2, weapon)
              );
            }
            while (this.orbitalDrones.length > count) {
              this.orbitalDrones.pop();
            }

            this.orbitalDrones.forEach((drone, i) => drone.update(i, count));
          }
        }

        shoot() {
          // Atira com arma principal
          if (this.cooldown <= 0) {
            // Se a arma tem burst, dispara m√∫ltiplos tiros
            if (this.primaryWeapon.type.burst) {
              const burstCount = this.primaryWeapon.type.burstCount || 3;
              const burstDelay = this.primaryWeapon.type.burstDelay || 5;
              
              for (let i = 0; i < burstCount; i++) {
                setTimeout(() => {
            this.fireWeapon(this.primaryWeapon);
                }, i * burstDelay * 16); // ~16ms por frame
              }
            } else {
              this.fireWeapon(this.primaryWeapon);
            }
            this.cooldown = this.primaryWeapon.cooldown;
          }
        }

        fireWeapon(weapon) {
          const centerY = this.y + this.height / 2;

          if (weapon.name === "MINE") {
            const mineX = this.x + this.width + 20;
            const mineY = this.y + this.height / 2;
            game.projectiles.push(
              new ProximityMineProjectile(mineX, mineY, weapon.damage)
            );
            return;
          }

          if (weapon.name === "TURRET") {
            // Torreta atira para frente e diagonais
            game.projectiles.push(
              new Projectile(this.x + this.width, centerY, weapon, 0)
            );
            game.projectiles.push(
              new Projectile(this.x + this.width, centerY, weapon, -3)
            );
            game.projectiles.push(
              new Projectile(this.x + this.width, centerY, weapon, 3)
            );
            return;
          }

          if (weapon.name === "BEAM") {
            // Raios laterais (cima e baixo)
            const topY = this.y;
            const bottomY = this.y + this.height;
            game.projectiles.push(
              new Projectile(this.x + this.width, topY, weapon, 0)
            );
            game.projectiles.push(
              new Projectile(this.x + this.width, bottomY, weapon, 0)
            );
            return;
          }

          if (weapon.name === "SHIELD") {
            // Shield √© passivo, s√≥ ativa quando tomar dano
            if (!this.shieldActive) {
              this.shieldActive = true;
              this.shieldTimer = 180; // 3 segundos
            }
            return;
          }

          if (weapon.spread) {
            const angles = [-2, 0, 2];
            for (let angle of angles) {
              game.projectiles.push(
                new Projectile(this.x + this.width, centerY, weapon, angle)
              );
            }
          } else {
            game.projectiles.push(
              new Projectile(this.x + this.width, centerY, weapon)
            );
          }
        }
      }

      class Projectile {
        constructor(x, y, weapon, verticalOffset = 0) {
          this.x = x;
          this.y = y;
          this.speed = weapon.speed;
          // Aplica multiplicador de dano baseado em upgrades
          const damageMultiplier = 1 + (game.upgrades.damage * 0.20);
          this.damage = weapon.damage * damageMultiplier;
          this.color = weapon.color;
          this.weaponName = weapon.name;
          this.width = 10;
          this.height = 3;
          this.verticalOffset = verticalOffset;
          this.homing = weapon.homing || false;
          this.lifetime = 300;
          this.wobbleY = weapon.wobbleY || 0;
          this.baseY = this.y;
          this.frameCount = 0;

          this.vx = this.speed;
          this.vy = verticalOffset;

          if (this.homing) {
            this.target = null;
          }
        }

        draw() {
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        update() {
          if (this.homing) {
            this.lifetime--;
            if (this.lifetime <= 0) this.dead = true;

            if (
              !this.target ||
              this.target.health <= 0 ||
              this.target.x + this.target.width < 0
            ) {
              const newTarget = game.enemies
                .filter((e) => e.x > game.player.x && e.health > 0)
                .sort((a, b) => a.x - b.x)[0];

              if (newTarget) {
                this.target = newTarget;
              } else {
                this.x += this.vx;
                this.y += this.vy;
                this.checkOutOfBounds();
                return;
              }
            }

            // Ajusta trajet√≥ria em dire√ß√£o ao alvo travado
            const dx = this.target.x + this.target.width / 2 - this.x;
            const dy = this.target.y + this.target.height / 2 - this.y;
            const mag = Math.sqrt(dx * dx + dy * dy) || 1;
            this.vx = (dx / mag) * this.speed;
            this.vy = (dy / mag) * this.speed;

            this.x += this.vx;
            this.y += this.vy;
          } else {
            // Proj√©til comum
            this.x += this.speed;
            this.frameCount++;

            if (this.wobbleY) {
                const noise = (Math.random() - 0.5) * this.wobbleY * 2; // ru√≠do aleat√≥rio leve
                this.y += noise;
            } else {
              this.y += this.verticalOffset;
            }
          }

          this.checkOutOfBounds();
        }

        checkOutOfBounds() {
          if (
            this.x > canvas.width ||
            this.x + this.width < 0 ||
            this.y < 0 ||
            this.y > canvas.height
          ) {
            this.dead = true;
          }
        }
      }

      class EnemyProjectile {
        constructor(x, y, damage = 1) {
          this.x = x;
          this.y = y;
          this.speed = 4;
          this.width = 8;
          this.height = 3;
          this.damage = damage;
        }

        draw() {
          ctx.fillStyle = "purple";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        update() {
          this.x -= this.speed;
        }
      }

      class EnemyProjectileAngular {
        constructor(x, y, targetX, targetY, damage = 2) {
          this.x = x;
          this.y = y;
          const dx = targetX - x;
          const dy = targetY - y;
          const magnitude = Math.sqrt(dx * dx + dy * dy);
          this.vx = (dx / magnitude) * 4;
          this.vy = (dy / magnitude) * 4;
          this.width = 8;
          this.height = 3;
          this.damage = damage;
        }

        draw() {
          ctx.fillStyle = "orange";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
        }
      }
      // Classe para part√≠culas de chama da turbina
      class FlameParticle {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.vx = Math.random() * 2 + 1; // Move para a direita (tr√°s da nave que vai para esquerda)
          this.vy = (Math.random() - 0.5) * 1; // Movimento vertical aleat√≥rio
          this.size = Math.random() * 1 + 2; // Tamanho entre 3-9
          this.life = 15; // Vida da part√≠cula em frames
          this.maxLife = this.life;
          // Cores variadas para o fogo
          const colors = ['#FF4500', '#FF6347', '#FF8C00', '#FFD700', '#FFA500', '#FF0000'];
          this.color = colors[Math.floor(Math.random() * colors.length)];
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.life--;
          this.size *= 0.95; // Diminui gradualmente
        }

        draw() {
          const alpha = this.life / this.maxLife;
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        get dead() {
          return this.life <= 0;
        }
      }

      class Enemy {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.width = 50;
          this.height = 50;
          this.speed = 2;
          this.cooldown = Math.random() * 180 + 60;
          this.damage = 1;
          this.flameParticles = []; // Array de part√≠culas de chama
          this.flameSpawnCounter = 0; // Contador para spawn de part√≠culas
          // Balan√ßo vertical
          this.wobbleOffset = Math.random() * Math.PI * 2; // Offset aleat√≥rio para varia√ß√£o
          this.wobbleSpeed = 0.06; // Velocidade do balan√ßo
          this.wobbleAmplitude = 15; // Amplitude do balan√ßo (pixels)
          this.baseY = y; // Posi√ß√£o Y base
          this.wobbleCounter = 0; // Contador para anima√ß√£o
        }

        draw() {
          // Desenha part√≠culas de chama primeiro (atr√°s do inimigo)
          this.flameParticles.forEach(p => p.draw());
          
          // Desenha o inimigo
          if (IMAGES.inimigo1 && IMAGES.inimigo1.complete) {
            ctx.drawImage(IMAGES.inimigo1, this.x, this.y, this.width, this.height);
          } else {
            // Fallback caso a imagem n√£o carregue
            ctx.fillStyle = "#594700";
            ctx.fillRect(this.x, this.y, this.width, this.height);
          }
        }

        update() {
          this.x -= this.speed;
          
          // Balan√ßo vertical suave
          this.wobbleCounter += this.wobbleSpeed;
          this.y = this.baseY + Math.sin(this.wobbleCounter + this.wobbleOffset) * this.wobbleAmplitude;
          
          this.cooldown--;
          if (this.cooldown <= 0) {
            game.enemyProjectiles.push(
              new EnemyProjectile(this.x, this.y + this.height / 2, this.damage)
            );
            this.cooldown = Math.random() * 180 + 60;
          }
          
          // Sistema de part√≠culas de chama da turbina
          this.flameSpawnCounter++;
          if (this.flameSpawnCounter >= 3) { // Cria part√≠culas a cada 3 frames
            this.flameSpawnCounter = 0;
            // Posi√ß√£o da turbina (traseira do inimigo, centro vertical)
            const turbineX = this.x + this.width  // Traseira da nave
            const turbineY = this.y + this.height / 2; // Centro vertical
            
            // Cria 2-3 part√≠culas por vez para um efeito mais denso
            const particleCount = Math.floor(Math.random() * 2) + 2;
            for (let i = 0; i < particleCount; i++) {
              this.flameParticles.push(new FlameParticle(turbineX, turbineY + (Math.random() - 0.5) * 10));
            }
          }
          
          // Atualiza e remove part√≠culas mortas
          this.flameParticles.forEach(p => p.update());
          this.flameParticles = this.flameParticles.filter(p => !p.dead);
        }
      }

      class MiniBoss extends Enemy {
        constructor(x, y) {
          super(x, y);
          this.width = 120;
          this.height = 80;
          this.maxHealth = 50;
          this.health = 50;
          this.speed = 1;
          this.cooldown = 90;
        }

        update() {
          const player = game.player;
          const targetX = 400; // posi√ß√£o que o miniboss tenta manter
          const dodgeRange = 100;
          const dodgeIntensity = 3;

          // Inicializa vari√°veis de controle (se ainda n√£o tiverem)
          if (this.dodgeCooldown === undefined) this.dodgeCooldown = 0;
          if (this.evadeDirection === undefined) this.evadeDirection = 0;

          // üü¶ Movimento horizontal inteligente
          const buffer = 30; // margem de seguran√ßa entre o player e o miniboss
          // const targetX = 400;

          if (player.x > this.x + buffer) {
            // Player passou do miniboss ‚Üí miniboss recua
            this.x += 1.5;
          } else if (this.x > targetX + 5) {
            // Retorna suavemente para a posi√ß√£o padr√£o
            this.x -= 1;
          } else if (this.x < targetX - 5) {
            this.x += 1;
          }

          // üü• Evas√£o de proj√©teis
          if (this.dodgeCooldown <= 0) {
            for (let p of game.projectiles) {
              const closeX =
                p.x > this.x - dodgeRange && p.x < this.x + this.width;
              const closeY =
                p.y > this.y - 30 && p.y < this.y + this.height + 30;
              if (closeX && closeY) {
                this.evadeDirection = p.y < this.y ? 1 : -1;
                this.dodgeCooldown = 30;
                break;
              }
            }
          } else {
            this.dodgeCooldown--;
          }

          // Aplica evasiva suavizada
          this.y += this.evadeDirection * dodgeIntensity;
          this.evadeDirection *= 0.9;

          // üü® Segue levemente o player se n√£o estiver esquivando
          if (Math.abs(this.evadeDirection) < 0.1) {
            const dy = (player.y - this.y) * 0.02;
            this.y += dy;
          }

          // üî∫ Ataque padr√£o
          this.cooldown--;
          if (this.cooldown <= 0) {
            for (let i = -1; i <= 1; i++) {
              const angle = i * 0.2;
              const speed = 5;
              const vx = Math.cos(angle) * -speed;
              const vy = Math.sin(angle) * speed;
              game.enemyProjectiles.push(
                new MiniBossProjectile(this.x, this.y + this.height / 2, vx, vy)
              );
            }
            this.cooldown = 90;
          }
        }

        draw() {
          ctx.fillStyle = "#880000";
          ctx.fillRect(this.x, this.y, this.width, this.height);

          ctx.fillStyle = "black";
          ctx.fillRect(this.x, this.y - 10, this.width, 6);
          ctx.fillStyle = "red";
          ctx.fillRect(
            this.x,
            this.y - 10,
            this.width * (this.health / this.maxHealth),
            6
          );
        }

        takeDamage(dmg) {
          this.health -= dmg;
          if (this.health <= 0) {
            this.dead = true;
            game.damageTexts.push(
              new DamageText(this.x, this.y, "Boss Defeated!", "red")
            );
            // DESABILITADO: Boss agora dropa moedas ao inv√©s de powerup
            // game.powerUps.push(
            //   new DropInstance(this.x, this.y, DropTypes.RAPID)
            // );
            
            // Boss dropa muitas moedas
            for (let i = 0; i < 10; i++) {
              const offsetX = (Math.random() - 0.5) * 80;
              const offsetY = (Math.random() - 0.5) * 80;
              game.coinsDropped.push(new CoinDrop(this.x + offsetX, this.y + offsetY, 5));
            }
            
            // Boss sempre dropa 2 vidas
            game.powerUps.push(new PowerUp(this.x - 30, this.y));
            game.powerUps.push(new PowerUp(this.x + 30, this.y));
            
            return true;
          }
          return false;
        }
      }

      class MiniBossProjectile {
        constructor(x, y, vx, vy) {
          this.x = x;
          this.y = y;
          this.vx = vx;
          this.vy = vy;
          this.width = 10;
          this.height = 4;
          this.damage = 2;
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
        }

        draw() {
          ctx.fillStyle = "darkred";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }
      }

      class Tank {
        constructor(x) {
          this.x = x;
          this.y = canvas.height - canvas.height * 0.1 - 40;
          this.width = 60;
          this.height = 40;
          this.speed = 1.2;
          this.cooldown = Math.random() * 180 + 60;
        }

        draw() {
          ctx.fillStyle = "#333";
          ctx.fillRect(this.x, this.y, this.width, this.height);
          ctx.fillStyle = "#666";
          ctx.fillRect(this.x + 10, this.y - 10, 40, 10);
        }

        update() {
          this.x -= this.speed;
          this.cooldown--;
          if (this.cooldown <= 0) {
            const target = game.player;
            game.enemyProjectiles.push(
              new EnemyProjectileAngular(
                this.x,
                this.y + this.height / 2,
                target.x + target.width / 2,
                target.y + target.height / 2
              )
            );
            this.cooldown = Math.random() * 180 + 60;
          }
        }
      }

      class BomberEnemy extends Enemy {
        constructor(x, y) {
          super(x, y);
          this.width = 40;
          this.height = 40;
          this.damage = 1;
        }

        update() {
          this.x -= this.speed;
          this.cooldown--;
          if (this.cooldown <= 0) {
            for (let i = -1; i <= 1; i++) {
              game.enemyProjectiles.push(
                new EnemyProjectile(this.x, this.y + i * 10, this.damage)
              );
            }
            this.cooldown = Math.random() * 150 + 80;
          }
        }

        draw() {
          ctx.fillStyle = "#ff5555";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }
      }

      class SniperEnemy extends Enemy {
        constructor(x, y) {
          super(x, y);
          this.cooldown = 240;
          this.width = 20;
          this.height = 60;
          this.damage = 2;
        }

        update() {
          this.x -= this.speed * 0.5;
          this.cooldown--;
          if (this.cooldown <= 0) {
            const target = game.player;
            game.enemyProjectiles.push(
              new EnemyProjectileAngular(
                this.x,
                this.y + this.height / 2,
                target.x + target.width / 2,
                target.y + target.height / 2,
                this.damage
              )
            );
            this.cooldown = 240;
          }
        }

        draw() {
          ctx.fillStyle = "#3333cc";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }
      }

      class ShieldedEnemy extends Enemy {
        constructor(x, y) {
          super(x, y);
          this.shielded = true;
          this.width = 30;
          this.height = 50;
        }

        draw() {
          ctx.fillStyle = this.shielded ? "#88f" : "#f88";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        hit() {
          if (this.shielded) {
            this.shielded = false;
            return false;
          } else {
            return true;
          }
        }
      }

      class DiveEnemy {
        constructor(x) {
          const player = game.player;
          this.x = x;
          this.y = player.y; // Inicia na mesma altura que o player
          this.width = 30;
          this.height = 30;
          this.speed = 5;
          this.phase = "approaching";
          this.attackSpeed = 6;
          this.exitSpeed = 4;
          this.triggerDistance = 250;
          this.shot = false;
        }

        update() {
          const player = game.player;

          if (this.phase === "approaching") {
            this.x -= this.speed;

            const dx = this.x - (player.x + player.width);
            if (dx < this.triggerDistance) {
              this.phase = "diving";
            }
          } else if (this.phase === "diving") {
            this.y += this.attackSpeed;
            this.x -= this.speed * 0.5;

            if (!this.shot && Math.abs(this.y - player.y) < 30) {
              game.enemyProjectiles.push(
                new EnemyProjectile(this.x, this.y + this.height / 2)
              );
              this.shot = true;
            }

            if (this.y > player.y + 50) {
              this.phase = "exiting";
            }
          } else if (this.phase === "exiting") {
            this.y -= this.exitSpeed;
            this.x -= this.speed * 0.5;
          }
        }

        draw() {
          ctx.fillStyle = "#ffaa00";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }
      }

      class DroneEnemy extends Enemy {
        constructor(x, y) {
          super(x, y);
          this.width = 20;
          this.height = 20;
          this.speed = 2.5;
          this.cooldown = 60 + Math.random() * 60;
          this.damage = 1;
        }

        draw() {
          ctx.fillStyle = "#00ccff";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        update() {
          this.x -= this.speed;
          this.cooldown--;
          if (this.cooldown <= 0) {
            game.enemyProjectiles.push(
              new EnemyProjectile(this.x, this.y + this.height / 2)
            );
            this.cooldown = 90 + Math.random() * 90;
          }
        }
      }

      function dropOnEnemyDeath(enemy) {
        const dropChance = Math.random();

        if (dropChance < 0.1) {
          // 10% de chance de soltar vida
          game.powerUps.push(new PowerUp(enemy.x, enemy.y));
        } else if (dropChance < 0.2) {
          // 10% de chance de soltar arma
          const allTypes = [
            ...Object.values(WeaponTypes),
            ...Object.values(AuxiliaryWeaponTypes),
          ];
          const type = allTypes[Math.floor(Math.random() * allTypes.length)];
          game.powerUps.push(new WeaponPowerUp(enemy.x, enemy.y, type));
        }
      }

      function spawnDroneFormation(size = 3) {
        const baseX = canvas.width + 50;
        const baseY = 50 + Math.random() * (canvas.height - 200);
        const drones = [];

        for (let i = 0; i < size; i++) {
          const offsetY = i * 30;
          drones.push(new DroneEnemy(baseX + i * 30, baseY + offsetY));
        }

        return drones; // ‚úÖ retorna array de DroneEnemy
      }

      function spawnArrowFormationGeneric(
        enemyClass,
        size = 6,
        direction = "<",
        spacingX = 30,
        spacingY = 20
      ) {
        const enemies = [];
        const baseX = canvas.width + 50;

        const groundHeight = canvas.height * 0.1;
        const safetyMargin = 60;

        // Altura total da forma√ß√£o vertical
        const formationHeight = (size - 1) * spacingY;

        // Limites seguros
        const minY = safetyMargin + formationHeight / 2;
        const maxY = canvas.height - groundHeight - formationHeight / 2;
        const centerY = minY + Math.random() * (maxY - minY);

        const half = Math.floor(size / 2);

        for (let i = 0; i < size; i++) {
          const offset = Math.abs(i - half);
          let x, y;

          switch (direction) {
            case "<": // seta para esquerda
              x = baseX + i * spacingX;
              y = centerY + offset * spacingY;
              break;
            case ">": // seta para direita
              x = baseX - i * spacingX;
              y = centerY + offset * spacingY;
              break;
            case "V": // seta para baixo
              x = baseX + offset * spacingX;
              y = centerY + i * spacingY;
              break;
            case "^": // seta para cima
              x = baseX + offset * spacingX;
              y = centerY - i * spacingY;
              break;
          }

          enemies.push(new enemyClass(x, y));
        }

        return enemies;
      }

      class DamageText {
        constructor(x, y, text, color = "yellow") {
          this.x = x;
          this.y = y;
          this.text = text;
          this.color = color;
          this.alpha = 1;
          this.lifetime = 60;
        }

        draw() {
          ctx.globalAlpha = this.alpha;
          ctx.fillStyle = this.color;
          ctx.font = "16px Arial";
          ctx.fillText(this.text, this.x, this.y);
          ctx.globalAlpha = 1.0;
        }

        update() {
          this.y -= 0.5;
          this.alpha -= 1 / this.lifetime;
        }

        isAlive() {
          return this.alpha > 0;
        }
      }

      // Ajustar inimigos para ter vida e barra de vida
      function addHealthToEnemy(cls, baseHealth = 1) {
        return class extends cls {
          constructor(...args) {
            super(...args);
            this.maxHealth = baseHealth;
            this.health = baseHealth;
          }

          draw() {
            super.draw();
            ctx.fillStyle = "gray";
            ctx.fillRect(this.x, this.y - 6, this.width, 5);
            ctx.fillStyle = "lime";
            ctx.fillRect(
              this.x,
              this.y - 6,
              this.width * (this.health / this.maxHealth),
              5
            );
            ctx.strokeStyle = "black";
            ctx.strokeRect(this.x, this.y - 6, this.width, 5);
          }

          takeDamage(amount = 1) {
            this.health -= amount;
            return this.health <= 0;
          }
        };
      }

      // Adiciona sa√∫de aos inimigos
      Enemy = addHealthToEnemy(Enemy, 1);
      BomberEnemy = addHealthToEnemy(BomberEnemy, 3 );
      SniperEnemy = addHealthToEnemy(SniperEnemy, 4);
      DiveEnemy = addHealthToEnemy(DiveEnemy, 2);
      ShieldedEnemy = class extends addHealthToEnemy(ShieldedEnemy, 10) {
        takeDamage(amount = 1) {
          if (this.shielded) {
            this.shielded = false;
            game.damageTexts.push(
              new DamageText(this.x, this.y, "Shield Down", "cyan")
            );
            return false;
          } else {
            return super.takeDamage(amount);
          }
        }
      };
      Tank = addHealthToEnemy(Tank, 5);
      DroneEnemy = addHealthToEnemy(DroneEnemy, 1);


      // ============================================
      // SISTEMA DE WAVES - CONFIGUR√ÅVEL
      // ============================================
      
      const WaveConfig = {
        // Configura√ß√£o de waves espec√≠ficas (1-20)
        waves: {
          1: { enemies: 5, tanks: 0, boss: false },
          2: { enemies: 6, tanks: 0, boss: false },
          3: { enemies: 7, tanks: 1, boss: false },
          4: { enemies: 8, tanks: 1, boss: false },
          5: { enemies: 10, tanks: 2, boss: true }, // Boss
          6: { enemies: 9, tanks: 2, boss: false },
          7: { enemies: 10, tanks: 2, boss: false },
          8: { enemies: 12, tanks: 3, boss: false },
          9: { enemies: 13, tanks: 3, boss: false },
          10: { enemies: 15, tanks: 3, boss: true }, // Boss
          11: { enemies: 14, tanks: 4, boss: false },
          12: { enemies: 15, tanks: 4, boss: false },
          13: { enemies: 16, tanks: 4, boss: false },
          14: { enemies: 17, tanks: 5, boss: false },
          15: { enemies: 20, tanks: 5, boss: true }, // Boss
          16: { enemies: 18, tanks: 5, boss: false },
          17: { enemies: 19, tanks: 6, boss: false },
          18: { enemies: 20, tanks: 6, boss: false },
          19: { enemies: 22, tanks: 7, boss: false },
          20: { enemies: 25, tanks: 8, boss: true }, // Boss
        },
        
        // Configura√ß√£o padr√£o para waves 21+ (escala infinitamente)
        getWaveConfig(wave) {
          if (this.waves[wave]) {
            return this.waves[wave];
          }
          
          // Para waves 21+, escala automaticamente
          const enemies = Math.min(20 + Math.floor((wave - 20) * 1.5), 40);
          const tanks = Math.min(5 + Math.floor((wave - 20) / 2), 15);
          const boss = wave % 5 === 0; // Boss a cada 5 waves
          
          return { enemies, tanks, boss };
        },
        
        // Recompensa de moedas por wave
        getCoinReward(wave) {
          const baseReward = 10;
          const waveBonus = wave * 5;
          const config = this.getWaveConfig(wave);
          const bossBonus = config.boss ? 50 : 0;
          
          return baseReward + waveBonus + bossBonus;
        }
      };
      
      const WaveSystem = {
        currentWave: 0,
        waveActive: false,
        
        startWave(waveNumber) {
          this.currentWave = waveNumber;
          this.waveActive = true;
          
          // Spawna os inimigos da wave
          this.spawnWaveEnemies(waveNumber);
        },
        
        spawnWaveEnemies(wave) {
          const config = WaveConfig.getWaveConfig(wave);
          
          // Spawna inimigos em forma√ß√µes variadas
          let spawnedEnemies = 0;
          let formationDelay = 0;
          
          while (spawnedEnemies < config.enemies) {
            const remaining = config.enemies - spawnedEnemies;
            const formationType = Math.random();
            
            // Closure para capturar delay atual
            ((delay) => {
              setTimeout(() => {
                if (formationType < 0.3 && remaining >= 5) {
                  // Forma√ß√£o em seta
                  const formation = spawnArrowFormationGeneric(Enemy, Math.min(5, remaining), "<");
                  if (formation) {
                    const enemies = Array.isArray(formation) ? formation : [formation];
                    game.enemies.push(...enemies);
                  }
                } else if (formationType < 0.5 && remaining >= 4 && wave >= 3) {
                  // Forma√ß√£o de drones (wave 3+)
                  const formation = spawnDroneFormation(Math.min(4, remaining));
                  if (formation) {
                    const enemies = Array.isArray(formation) ? formation : [formation];
                    game.enemies.push(...enemies);
                  }
                } else {
                  // Spawn individual
                  const x = canvas.width + 50 + Math.random() * 100;
                  const y = 50 + Math.random() * (canvas.height * 0.6);
                  game.enemies.push(new Enemy(x, y));
                }
              }, delay);
            })(formationDelay);
            
            // Incrementa contadores
            if (formationType < 0.3 && remaining >= 5) {
              spawnedEnemies += 5;
            } else if (formationType < 0.5 && remaining >= 4 && wave >= 3) {
              spawnedEnemies += 4;
            } else {
              spawnedEnemies++;
            }
            
            formationDelay += 1500; // 1.5 segundos entre forma√ß√µes
          }
          
          // Spawna tanks com delay
          for (let i = 0; i < config.tanks; i++) {
            setTimeout(() => {
              const x = canvas.width + 100 + Math.random() * 200;
              game.tanks.push(new Tank(x));
            }, (i + 1) * 2000 + formationDelay); // Ap√≥s as forma√ß√µes
          }
          
          // Spawna boss depois de todos os inimigos
          if (config.boss) {
            setTimeout(() => {
              game.enemies.push(new MiniBoss(canvas.width + 100, canvas.height / 2));
            }, 3000 + formationDelay); // Ap√≥s tudo
          }
        },
        
        checkWaveComplete() {
          // Verifica se todos os inimigos e tanks foram mortos
          if (this.waveActive && game.enemies.length === 0 && game.tanks.length === 0) {
            this.waveActive = false;
            this.onWaveComplete();
          }
        },
        
        onWaveComplete() {
          // Recompensa de moedas
          const coinReward = WaveConfig.getCoinReward(this.currentWave);
          game.coins += coinReward;
          
          // Aguarda um frame antes de iniciar pr√≥xima wave (evita loop infinito)
          setTimeout(() => {
            const nextWave = this.currentWave + 1;
            this.startWave(nextWave);
          }, 100);
        }
      };

      const waves = [
            () => spawnArrowFormationGeneric(Enemy, 5),
            () => spawnDroneFormation(6),
            () => game.enemies.push(new MiniBoss(canvas.width + 100, 200)),
            () => spawnArrowFormationGeneric(SniperEnemy, 7),
            () => {
                spawnArrowFormationGeneric(Enemy, 3);
                spawnArrowFormationGeneric(DroneEnemy, 6);
            },
            () => game.enemies.push(new MiniBoss(canvas.width + 100, 250)),
            ];

            let currentWave = 0;
            let waveCountdown = 180; // 3 segundos
            let showingWaveText = false;
            let waveTextTimer = 60;


      function novoInimigoAleatorio() {
        const tipo = Math.random();
        const x = canvas.width + Math.random() * 400;

        const groundHeight = canvas.height * 0.1;
        const yMax = canvas.height - groundHeight - 50;
        const y = Math.random() * yMax;

        if (tipo < 0.2) return [new BomberEnemy(x, y)];
        if (tipo < 0.4)
          return spawnArrowFormationGeneric(
            SniperEnemy,
            Math.floor(Math.random() * 1) + 3,
            ">"
          );
        if (tipo < 0.6)
          return spawnArrowFormationGeneric(
            ShieldedEnemy,
            Math.floor(Math.random() * 3) + 3,
            "<"
          );
        if (tipo < 0.8)
          return spawnArrowFormationGeneric(
            DiveEnemy,
            Math.floor(Math.random() * 3) + 3,
            "^"
          );

        // 15% de chance de Stealth (ainda ser√° implementado se quiser)
        // if (tipo < 0.95) return nessw StealthEnemy(x, y);

        if (tipo < 0.95) {
          return spawnArrowFormationGeneric(
            DroneEnemy,
            Math.floor(Math.random() * 12) + 12,
            "^"
          );
        }

        return null;
      }

      function isOverlapping(a, b, padding = 75) {
        return (
          a.x < b.x + b.width + padding &&
          a.x + a.width + padding > b.x &&
          a.y < b.y + b.height + padding &&
          a.y + a.height + padding > b.y
        );
      }
      function spawnWithDistance(factory, existingList, maxAttempts = 15) {
        let attempts = 0;
        while (attempts < maxAttempts) {
          const result = factory();
          if (!result) return null;

          const newEnemies = Array.isArray(result) ? result : [result];

          const hasOverlap = newEnemies.some((newEnemy) =>
            existingList.some((existing) => isOverlapping(newEnemy, existing))
          );

          if (!hasOverlap) return newEnemies;
          attempts++;
        }

        return factory();
      }

      const game = window.game = {
        debug: false, // Modo debug (ativa/desativa informa√ß√µes na tela)
        player: new Player(),
        projectiles: [],
        enemyProjectiles: [],
        enemies: [],
        tanks: [],
        powerUps: [],
        coinsDropped: [],
        grassXs: [],
        parallaxLayers: [],
        comboSystem: new ComboSystem(),
        countdownSystem: new CountdownSystem(),
        score: 0,
        coins: 0, // Moedas coletadas
        lives: 3, // Vidas restantes
        highScore: 0,
        highWave: 0,
        // Upgrades permanentes
        upgrades: {
          damage: 0,      // N√≠vel de upgrade de dano (0-5)
          speed: 0,       // N√≠vel de upgrade de velocidade (0-5)
          maxHealth: 0,   // N√≠vel de upgrade de vida m√°xima (0-5)
          fireRate: 0,    // N√≠vel de upgrade de taxa de tiro (0-5)
          regen: false    // Regenera√ß√£o (true/false)
        },
        fps: 60,
        lastFrameTime: 0,
        gameOver: false,
        gameOverEventSent: false,
        isPaused: false,
        damageTexts: [],
        regenTimer: 0, // Timer para regenera√ß√£o (600 frames = 10 segundos a 60fps)
        miniBoss: null,
        bossTimer: 2500,
        bossActive: false,
        particles: [],

        init() {
          // Carrega save antes de resetar
          const saveData = SaveSystem.load();
          
          this.reset();
          
          // Aplica save carregado
          if (saveData) {
            SaveSystem.applyLoad(saveData);
          }
          
          // Inicia o countdown antes de come√ßar o jogo (sem mensagem na primeira wave)
          this.isPaused = true; // Pausa durante o countdown
          this.countdownSystem.start(() => {
            this.isPaused = false; // Despausa quando countdown terminar
            WaveSystem.startWave(1); // Inicia a wave 1
          }, ""); // Sem mensagem na primeira wave
          
          this.loop(0);
        },

        handleGameOver() {
          this.gameOver = true;
          this.lives--;
          
          // Atualiza high score e high wave
          if (this.score > this.highScore) {
            this.highScore = this.score;
          }
          if (WaveSystem.currentWave > this.highWave) {
            this.highWave = WaveSystem.currentWave;
          }
          
          if (this.lives <= 0) {
            // Perdeu todas as vidas - limpa save
            SaveSystem.clear();
            
            // Reseta tudo para valores iniciais
            setTimeout(() => {
              this.lives = 3;
              this.coins = 0;
              this.highScore = 0;
              this.highWave = 0;
              this.reset();
              this.gameOver = false;
            }, 3000);
          } else {
            // Ainda tem vidas - salva progresso e reinicia
            SaveSystem.save();
            setTimeout(() => {
              this.reset();
              this.gameOver = false;
              WaveSystem.startWave(1);
            }, 2000);
          }
        },

        reset() {
          this.player = new Player();
          this.projectiles = [];
          this.enemyProjectiles = [];
          this.powerUps = [];
          this.coinsDropped = [];
          this.enemies = [];
          this.tanks = [];
          // N√ÉO reseta moedas e vidas (s√£o persistentes)

          // Inicializa camadas de parallax (da mais distante para a mais pr√≥xima)
          // Velocidades: mais longe = mais lento, mais perto = mais r√°pido
          this.parallaxLayers = [
            new ParallaxLayer(IMAGES.parallax1, 0.2, 0),  // C√©u/fundo mais distante
            new ParallaxLayer(IMAGES.parallax2, 0.4, 0),  // Montanhas distantes
            new ParallaxLayer(IMAGES.parallax3, 0.6, 0),  // Montanhas m√©dias
            new ParallaxLayer(IMAGES.parallax4, 0.8, 0),  // Colinas
            new ParallaxLayer(IMAGES.parallax5, 1.0, 0),  // Vegeta√ß√£o distante
            new ParallaxLayer(IMAGES.parallax6, 1.5, 0),  // Vegeta√ß√£o pr√≥xima
          ];

          for (let i = 0; i < 3; i++) {
            const result = spawnWithDistance(
              () => new Tank(canvas.width + i * 400),
              [...this.enemies, ...this.tanks]
            );
            if (result) {
              const tanks = Array.isArray(result) ? result : [result];
              this.tanks.push(...tanks);
            }
          }

          this.grassXs = Array.from(
            { length: Math.ceil(canvas.width / 20) + 2 },
            (_, i) => i * 20
          );
          this.score = 0;
          this.gameOver = false;
          this.gameOverEventSent = false;
          this.damageTexts = [];
          this.comboSystem.reset();
        },

        update() {
          if (this.gameOver) return;
          
          // Verifica se a wave foi completada
          WaveSystem.checkWaveComplete();
          
          this.player.update();
          game.player.targetX = null;
          game.player.targetY = null;
          
          // Sistema de regenera√ß√£o
          if (game.upgrades.regen && this.player.health < this.player.maxHealth) {
            this.regenTimer++;
            if (this.regenTimer >= 600) { // 10 segundos a 60fps
              this.player.health = Math.min(this.player.maxHealth, this.player.health + 1);
              this.regenTimer = 0;
              // Feedback visual
              game.damageTexts.push(new DamageText(this.player.x, this.player.y - 20, "+1 HP", "#00ff00"));
            }
          } else {
            this.regenTimer = 0;
          }
          
          this.comboSystem.update();
          this.damageTexts.forEach((dt) => dt.update());
          this.damageTexts = this.damageTexts.filter((dt) => dt.isAlive());

          game.projectiles = game.projectiles.filter((p) => !p.dead);
          game.particles = game.particles.filter((p) => !p.dead);
          game.particles.forEach((p) => p.update());

          this.projectiles.forEach((p) => p.update());
          this.projectiles = this.projectiles.filter((p) => !p.dead);
          this.projectiles = this.projectiles.filter(
            (p) =>
              p.x < canvas.width && p.y + p.height > 0 && p.y < canvas.height
          );

          this.enemyProjectiles.forEach((p) => p.update());
          this.enemyProjectiles = this.enemyProjectiles.filter(
            (p) =>
              p.x + p.width > 0 && p.y + p.height > 0 && p.y < canvas.height
          );



          // Checa se acabou a wave
        // Sistema de Waves (com prote√ß√£o)
        // if (!showingWaveText && currentWave < waves.length) {
        // // S√≥ conta se n√£o h√° inimigos vivos
        // if (game.enemies.length === 0) {
        //     waveCountdown--;

        //     if (waveCountdown <= 0) {
        //     const waveFn = waves[currentWave];
        //     if (typeof waveFn === "function") {
        //         const result = waveFn();
        //         if (Array.isArray(result)) game.enemies.push(...result);
        //     }
        //     currentWave++;
        //     showingWaveText = true;
        //     waveTextTimer = 60;
        //     waveCountdown = 180;
        //     }
        // }
        // }

           this.enemies.forEach((e) => e.update());
        //   console.log(this.enemies.length);
          // DESABILITADO: Spawn aleat√≥rio desabilitado, agora controlado por waves
          // if (
          //   this.enemies.length < 7 + this.score / 100 &&
          //   Math.random() < 0.005 &&
          //   !this.bossActive
          // ) {
          //   const result = spawnWithDistance(
          //     () => novoInimigoAleatorio(),
          //     this.enemies
          //   );
          //   if (result) {
          //     const newEnemies = Array.isArray(result) ? result : [result];
          //     this.enemies.push(...newEnemies); // ‚úÖ garante que sempre s√£o elementos individuais
          //   }
          // }
          this.enemies = this.enemies.filter(
            (e) =>
              e.x + e.width > 0 && e.y + e.height > 0 && e.y < canvas.height
          );

          this.tanks.forEach((t) => t.update());

          // DESABILITADO: Spawn aleat√≥rio de tanks desabilitado, agora controlado por waves
          // if (
          //   this.tanks.length < 3 &&
          //   Math.random() < 0.005 &&
          //   !this.bossActive
          // ) {
          //   const result = spawnWithDistance(
          //     () => new Tank(canvas.width + Math.random() * 400),
          //     this.tanks
          //   );
          //   if (result) {
          //     const tanks = Array.isArray(result) ? result : [result];
          //     this.tanks.push(...tanks);
          //   }
          // }
          this.tanks = this.tanks.filter((t) => t.x + t.width > 0);

          this.powerUps.forEach((p) => p.update());
          this.powerUps = this.powerUps.filter((p) => !p.dead);

          // Atualiza e coleta moedas
          this.coinsDropped.forEach((coin) => {
            coin.update();
            
            // Verifica colis√£o com o player
            const dx = (coin.x + coin.width / 2) - (this.player.x + this.player.width / 2);
            const dy = (coin.y + coin.height / 2) - (this.player.y + this.player.height / 2);
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 30) { // Raio de coleta
              coin.collected = true;
              this.coins += coin.value;
              
              // Efeito visual de coleta
              this.damageTexts.push(
                new DamageText(coin.x, coin.y - 10, `+${coin.value}‚≠ê`, "#FFD700")
              );
              
              // Efeito de part√≠culas
              for (let i = 0; i < 5; i++) {
                this.particles.push(
                  new ExplosionParticle(coin.x + coin.width / 2, coin.y + coin.height / 2, "#FFD700")
                );
              }
            }
          });
          this.coinsDropped = this.coinsDropped.filter((c) => !c.dead);

          this.projectiles.forEach((p, pi) => {
            this.enemies.forEach((e, ei) => {
              const hit =
                p.x < e.x + e.width &&
                p.x + p.width > e.x &&
                p.y < e.y + e.height &&
                p.y + p.height > e.y;
              if (hit) {
                HitEffectManager.spawnEffect(p.x, p.y, e.hitEffect);

                if (e.takeDamage && e.takeDamage(p.damage)) {
                  this.enemies.splice(ei, 1);
                  // const newEnemy = novoInimigoAleatorio();
                  // if (newEnemy) {
                  //     const list = Array.isArray(newEnemy) ? newEnemy : [newEnemy];
                  //     this.enemies.push(...list); // ‚úÖ garante que s√≥ elementos individuais entram
                  // }
                  // dropOnEnemyDeath(e); // <<<<< üéØ dropa algo aqui!
                  // 15% de chance de soltar drop
                  // DESABILITADO: Powerups foram desabilitados, agora s√≥ dropam moedas
                  // if (Math.random() < 0.75) {
                  //   const dropKeys = Object.keys(DropTypes);
                  //   const randomKey =
                  //     dropKeys[Math.floor(Math.random() * dropKeys.length)];
                  //   const dropType = DropTypes[randomKey];
                  //
                  //   this.powerUps.push(new DropInstance(e.x, e.y, dropType));
                  // }

                  // Adiciona kill ao combo e aplica multiplicador
                  this.comboSystem.addKill();
                  const points = Math.floor(1 * this.comboSystem.multiplier);
                  this.score += points;
                  
                  // Dropa moeda (30% de chance)
                  if (Math.random() < 0.3) {
                    this.coinsDropped.push(new CoinDrop(e.x, e.y, 1));
                  }
                  
                  // Dropa vida (10% de chance)
                  if (Math.random() < 0.1) {
                    this.powerUps.push(new PowerUp(e.x, e.y));
                  }
                  
                  // Mostra pontos ganhos
                  if (points > 1) {
                    this.damageTexts.push(
                      new DamageText(e.x, e.y - 20, `+${points}`, "yellow")
                    );
                  }
                }
                this.projectiles.splice(pi, 1);
                this.damageTexts.push(
                  new DamageText(e.x, e.y, "-" + p.damage.toFixed(2), "orange")
                );
              }
            });

            this.tanks.forEach((t, ti) => {
              const hit =
                p.x < t.x + t.width &&
                p.x + p.width > t.x &&
                p.y < t.y + t.height &&
                p.y + p.height > t.y;
              if (hit) {
                for (let i = 0; i < 6; i++) {
                  HitEffectManager.spawnEffect(t.x, t.y, t.hitEffect);
                }
                if (t.takeDamage && t.takeDamage(p.damage)) {
                  this.tanks.splice(ti, 1);
                  // this.tanks.push(new Tank(canvas.width + Math.random() * 400));
                  
                  // Adiciona kill ao combo e aplica multiplicador
                  this.comboSystem.addKill();
                  const points = Math.floor(2 * this.comboSystem.multiplier); // Tanks valem 2 pontos
                  this.score += points;
                  
                  // Dropa moedas (tanks sempre dropam 2-5 moedas)
                  const coinCount = Math.floor(Math.random() * 4) + 2;
                  for (let i = 0; i < coinCount; i++) {
                    const offsetX = (Math.random() - 0.5) * 40;
                    const offsetY = (Math.random() - 0.5) * 40;
                    this.coinsDropped.push(new CoinDrop(t.x + offsetX, t.y + offsetY, 2));
                  }
                  
                  // Dropa vida (25% de chance para tanks)
                  if (Math.random() < 0.25) {
                    this.powerUps.push(new PowerUp(t.x, t.y));
                  }
                  
                  // Mostra pontos ganhos
                  if (points > 2) {
                    this.damageTexts.push(
                      new DamageText(t.x, t.y - 20, `+${points}`, "yellow")
                    );
                  }
                }
                this.projectiles.splice(pi, 1);
                this.damageTexts.push(
                  new DamageText(t.x, t.y, "-" + p.damage.toFixed(2), "orange")
                );
              }
            });
          });

          for (let p of this.enemyProjectiles) {
            const hit =
              p.x < this.player.x + this.player.width &&
              p.x + p.width > this.player.x &&
              p.y < this.player.y + this.player.height &&
              p.y + p.height > this.player.y;
            if (hit && !this.player.invincible) {
              // Verifica se tem shield ativo
              if (this.player.shieldActive && this.player.shieldTimer > 0) {
                this.player.shieldTimer = 0;
                this.player.shieldActive = false;
                this.damageTexts.push(
                  new DamageText(this.player.x, this.player.y, "SHIELD!", "cyan")
                );
              } else {
              this.player.health--;
              this.player.invincibilityTimer = 180;
              this.damageTexts.push(
                new DamageText(
                  this.player.x,
                  this.player.y,
                  "-" + p.damage.toFixed(2),
                  "red"
                )
              );
              }
              this.enemyProjectiles = this.enemyProjectiles.filter(
                (ep) => ep !== p
              );
              if (this.player.health <= 0) {
                this.handleGameOver();
              }
              return;
            }
          }

          [
            ...this.enemies,
            ...this.tanks,
            ...(this.miniBoss ? [this.miniBoss] : []),
          ].forEach((e) => {
            const hit =
              this.player.x < e.x + e.width &&
              this.player.x + this.player.width > e.x &&
              this.player.y < e.y + e.height &&
              this.player.y + this.player.height > e.y;
            if (hit && !this.player.invincible) {
              // Verifica se tem shield ativo
              if (this.player.shieldActive && this.player.shieldTimer > 0) {
                this.player.shieldTimer = 0;
                this.player.shieldActive = false;
                this.damageTexts.push(
                  new DamageText(this.player.x, this.player.y, "SHIELD!", "cyan")
                );
              } else {
              this.player.health--;
              this.player.invincibilityTimer = 180;
              this.damageTexts.push(
                new DamageText(this.player.x, this.player.y, "-1", "red")
              );
              if (this.player.health <= 0) {
                  this.handleGameOver();
                }
              }
              return;
            }
          });

          // DESABILITADO: Powerups aleat√≥rios foram removidos
          // if (Math.random() < 0.002) {
          //   this.powerUps.push(
          //     new PowerUp(canvas.width, Math.random() * (canvas.height * 0.8))
          //   );
          // }

          // if (Math.random() < 0.002) {
          //   const allTypes = [
          //     ...Object.values(WeaponTypes),
          //     ...Object.values(AuxiliaryWeaponTypes),
          //   ];
          //   const type = allTypes[Math.floor(Math.random() * allTypes.length)];
          //   this.powerUps.push(
          //     new WeaponPowerUp(
          //       canvas.width,
          //       Math.random() * (canvas.height * 0.8),
          //       type
          //     )
          //   );
          // }

          for (let p of this.powerUps) {
            const collected =
              this.player.x < p.x + p.width &&
              this.player.x + this.player.width > p.x &&
              this.player.y < p.y + p.height &&
              this.player.y + this.player.height > p.y;
            if (collected) {
              this.powerUps = this.powerUps.filter((po) => po !== p);
              if (p instanceof WeaponPowerUp) {
                p.apply(this.player); // Troca a arma
                this.damageTexts.push(
                  new DamageText(p.x, p.y, p.weaponType.name, "blue")
                );
              } else if (p instanceof DropInstance) {
                p.apply(this.player); // Executa efeito do drop
              } else if (p instanceof PowerUp) {
                if (this.player.health < this.player.maxHealth) {
                  this.player.health++;
                  this.damageTexts.push(
                    new DamageText(p.x, p.y, "+1", "green")
                  );
                }
              }
            }
          }

          // mini-chefe
          if (!this.miniBoss && this.score >= 25 && this.bossTimer <= 0) {
            this.miniBoss = new MiniBoss(
              canvas.width + 50,
              canvas.height / 2 - 40
            );
            this.enemies = []; // limpa inimigos normais para dar espa√ßo
            this.bossActive = true;
          } else if (!this.miniBoss) {
            this.bossTimer--;
          }

          if (this.miniBoss) {
            this.miniBoss.update();
            if (this.miniBoss?.dead) {
              this.miniBoss = null;
              this.bossTimer = 2500;
              this.bossActive = false;
            }
          }

          if (this.miniBoss) {
            this.projectiles.forEach((p, pi) => {
              const b = this.miniBoss;
              const hit =
                p.x < b.x + b.width &&
                p.x + p.width > b.x &&
                p.y < b.y + b.height &&
                p.y + p.height > b.y;
              if (hit) {
                HitEffectManager.spawnEffect(p.x, p.y, b.hitEffect, 1.5);
                b.takeDamage(p.damage);
                this.projectiles.splice(pi, 1);
                this.damageTexts.push(
                  new DamageText(b.x, b.y, "-" + p.damage.toFixed(2), "orange")
                );
              }
            });
          }

          // Atualiza camadas de parallax
          this.parallaxLayers.forEach(layer => layer.update());

          if (this.player.airborne || controlMode === CONTROLSMODES.PLANE) {
            this.grassXs = this.grassXs.map((x) => {
              x -= 1;
              if (x < -20) x = canvas.width;
              return x;
            });
          }
        },

        draw() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          this.drawBackground();
          this.player.draw();
          this.projectiles.forEach((p) => p.draw());
          this.enemyProjectiles.forEach((p) => p.draw());
          this.enemies.forEach((e) => e.draw());
          this.tanks.forEach((t) => t.draw());
          this.powerUps.forEach((p) => p.draw());
          this.coinsDropped.forEach((c) => c.draw(ctx));
          this.damageTexts.forEach((dt) => dt.draw());

          ctx.fillStyle = "black";
          ctx.font = "12px Arial";
          ctx.fillText("Score: " + this.score, 20, 30);
          
          // Indicador de Wave
          ctx.fillStyle = "#FF4444";
          ctx.font = "bold 16px Arial";
          ctx.fillText("WAVE: " + WaveSystem.currentWave, 20, 50);
          
          // Indicador de Vidas
          ctx.fillStyle = "#FF1744";
          ctx.font = "bold 14px Arial";
          ctx.fillText("‚ù§Ô∏è x " + this.lives, 20, 70);
          
          ctx.fillStyle = "black";
          ctx.font = "12px Arial";
          ctx.fillText(
            "Weapon: " +
              this.player.primaryWeapon.name +
              " (Lv" +
              this.player.primaryWeapon.level +
              ")",
            20,
            90
          );

          // Se quiser exibir tamb√©m as auxiliares:
          const auxNames = 
            this.player.auxiliaryWeapons
            ?.map((w) => `${w.name} (Lv${w.level || 1})`)
            .join(", ");
          if (auxNames) {
            ctx.font = "12px Arial";
            ctx.fillText("Aux: " + auxNames, 20, 110);
          }

          // Contador de moedas (canto superior direito)
          const coinX = canvas.width / 2;
          const coinY = 20;
          
          // Background do contador
          ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
          ctx.strokeStyle = "#FFD700";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.roundRect(coinX - 10, coinY - 5, 110, 30, 15);
          ctx.fill();
          ctx.stroke();
          
          // √çcone da moeda
          ctx.fillStyle = "#FFD700";
          ctx.beginPath();
          ctx.arc(coinX + 10, coinY + 10, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#000";
          ctx.font = "bold 16px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("‚≠ê", coinX + 10, coinY + 10);
          
          // Quantidade de moedas
          ctx.fillStyle = "#FFD700";
          ctx.font = "bold 20px Arial";
          ctx.textAlign = "left";
          ctx.textBaseline = "middle";
          ctx.fillText(this.coins, coinX + 30, coinY + 10);

          // Informa√ß√µes de debug (s√≥ exibe se debug estiver ativo)
          if (this.debug) {
            ctx.fillStyle = "black";
            ctx.font = "14px Arial";
            ctx.fillText(
              "Enemies: " + this.enemies.length,
              canvas.width - 150,
              30
            );
            ctx.fillText(
              "Projectiles: " + this.projectiles.length,
              canvas.width - 150,
              50
            );
            ctx.fillText("FPS: " + this.fps, canvas.width - 150, 70);
            ctx.fillText(
              "Damage: " + this.player.primaryWeapon.damage,
              canvas.width - 150,
              90
            );
            ctx.fillText(
              "Cooldown: " + this.player.primaryWeapon.cooldown,
              canvas.width - 150,
              110
            );
          }

          // Desenha o combo
          this.comboSystem.draw(ctx);

          // Desenha o countdown (por cima de tudo)
          this.countdownSystem.draw(ctx);

          // Indicador de pause (s√≥ mostra se n√£o estiver no countdown)
          if (this.isPaused && !this.gameOver && !this.countdownSystem.active) {
            ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = "white";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 4;
            ctx.font = "bold 48px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            const text = "‚è∏Ô∏è PAUSADO";
            ctx.strokeText(text, canvas.width / 2, canvas.height / 2);
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
          }

          if (showingWaveText) {
        ctx.fillStyle = "white";
        ctx.font = "28px monospace";
        ctx.textAlign = "center";
        ctx.fillText(`Wave ${currentWave}`, canvas.width / 2, 80);
        waveTextTimer--;
        if (waveTextTimer <= 0) {
            showingWaveText = false;
        }
        }

          if (this.miniBoss) this.miniBoss.draw();
          game.particles.forEach((p) => p.draw());
          if (!this.player.airborne && !this.gameOver) {
            ctx.font = "16px Arial";
            ctx.fillText("Pressione espa√ßo para voar", 20, 80);
          }

          if (this.gameOver) {
            ctx.fillStyle = "red";
            ctx.font = "20px Arial";
            // Envia evento para Google Tag Manager apenas uma vez
            if (!this.gameOverEventSent) {
              window.dataLayer = window.dataLayer || [];
              window.dataLayer.push({
                'event': 'game_over',
              'event_category': 'game',
                'event_label': 'helicopter_shooter',
                'game_score': this.score
            });
              this.gameOverEventSent = true;
            }
            // Mensagem diferente baseada nas vidas restantes
            if (this.lives > 0) {
              ctx.fillText(
                `üíî VOC√ä MORREU! üíî`,
                canvas.width / 2 - 90,
                canvas.height / 2 - 20
              );
              ctx.font = "20px monospace";
              ctx.fillText(
                `Vidas restantes: ${this.lives}`,
                canvas.width / 2 - 100,
                canvas.height / 2 + 20
              );
            } else {
            ctx.fillText(
              "üí• GAME OVER üí•",
                canvas.width / 2 - 85,
                canvas.height / 2 - 20
              );
              ctx.font = "18px monospace";
              ctx.fillStyle = "#FFD700";
              ctx.fillText(
                `High Score: ${this.highScore}`,
                canvas.width / 2 - 80,
                canvas.height / 2 + 20
              );
              ctx.fillText(
                `High Wave: ${this.highWave}`,
                canvas.width / 2 - 70,
                canvas.height / 2 + 45
              );
            }
          }
        },

        drawBackground() {
          // Desenha camadas de parallax (da mais distante para a mais pr√≥xima)
          this.parallaxLayers.forEach(layer => layer.draw(ctx));

          // Desenha o ch√£o
          const groundY = canvas.height - canvas.height * 0.1;
          const grassY = groundY - 20;
          ctx.fillStyle = "#824f2b";
          ctx.fillRect(0, groundY, canvas.width, canvas.height * 0.1);
          
          // Desenha a grama
          for (let x of this.grassXs) {
            ctx.drawImage(IMAGES.grass, x, grassY, 20, 20);
          }
        },

        loop(timestamp) {
          const delta = timestamp - this.lastFrameTime;
          if (delta >= 500 / this.fps) {
            // Atualiza countdown sempre (mesmo pausado)
            this.countdownSystem.update();
            
            // S√≥ atualiza o resto se n√£o estiver pausado
            if (!this.isPaused) {
            this.update();
            }
            // Sempre desenha (para mostrar o estado pausado)
            this.draw();
            this.lastFrameTime = timestamp;
          }
          requestAnimationFrame((ts) => this.loop(ts));
        },
      };

      // ============================================
      // SISTEMA DE SAVE/LOAD - LOCALSTORAGE
      // ============================================
      
      const SaveSystem = {
        SAVE_KEY: 'helicopterShooterSave',
        
        save() {
          const saveData = {
            coins: game.coins,
            lives: game.lives,
            primaryWeapon: game.player.primaryWeapon.name,
            auxiliaryWeapons: game.player.auxiliaryWeapons.map(w => w.name),
            highScore: game.highScore || 0,
            highWave: game.highWave || 0,
            upgrades: game.upgrades
          };
          
          localStorage.setItem(this.SAVE_KEY, JSON.stringify(saveData));
        },
        
        load() {
          const savedData = localStorage.getItem(this.SAVE_KEY);
          if (!savedData) return null;
          
          try {
            return JSON.parse(savedData);
          } catch (e) {
            console.error('Erro ao carregar save:', e);
            return null;
          }
        },
        
        clear() {
          localStorage.removeItem(this.SAVE_KEY);
        },
        
        applyLoad(saveData) {
          if (!saveData) return;
          
          // Restaura moedas e vidas
          game.coins = saveData.coins || 0;
          game.lives = saveData.lives || 3;
          game.highScore = saveData.highScore || 0;
          game.highWave = saveData.highWave || 0;
          
          // Restaura upgrades
          if (saveData.upgrades) {
            game.upgrades = saveData.upgrades;
          }
          
          // Aplica upgrades ao player
          this.applyUpgradesToPlayer();
          
          // Restaura arma prim√°ria
          if (saveData.primaryWeapon && saveData.primaryWeapon !== 'BASIC') {
            const weapon = ShopSystem.primaryWeapons.find(w => w.name === saveData.primaryWeapon);
            if (weapon) {
              game.player.primaryWeapon = new WeaponInstance(weapon.type);
            }
          }
          
          // Restaura armas auxiliares
          if (saveData.auxiliaryWeapons && saveData.auxiliaryWeapons.length > 0) {
            game.player.auxiliaryWeapons = [];
            saveData.auxiliaryWeapons.forEach(weaponName => {
              const weapon = ShopSystem.auxiliaryWeapons.find(w => w.name === weaponName);
              if (weapon) {
                game.player.auxiliaryWeapons.push(new WeaponInstance(weapon.type));
              }
            });
          }
        },
        
        applyUpgradesToPlayer() {
          const player = game.player;
          
          // Aplica upgrade de vida m√°xima
          player.maxHealth = 5 + game.upgrades.maxHealth;
          if (player.health > player.maxHealth) {
            player.health = player.maxHealth;
          }
          
          // Aplica upgrade de velocidade (multiplicador)
          const baseSpeed = 8;
          player.speed = baseSpeed * (1 + (game.upgrades.speed * 0.15));
          
          // Upgrades de dano e fireRate s√£o aplicados diretamente nos proj√©teis/cooldown
        }
      };
      
      // ============================================
      // SISTEMA DE LOJA
      // ============================================
      
      const ShopSystem = {
        isOpen: false,
        
        // Cat√°logo de armas prim√°rias
        primaryWeapons: [
          {
            id: 'basic',
            name: 'BASIC',
            desc: 'Arma inicial - Tiro simples',
            price: 0,
            type: WeaponTypes.BASIC
          },
          {
            id: 'spread',
            name: 'SPREAD',
            desc: 'Dispara 3 proj√©teis em leque',
            price: 50,
            type: WeaponTypes.SPREAD
          },
          {
            id: 'burst',
            name: 'BURST',
            desc: 'Rajada r√°pida de 3 tiros',
            price: 80,
            type: WeaponTypes.BURST
          },
          {
            id: 'laser',
            name: 'LASER',
            desc: 'Raio laser cont√≠nuo',
            price: 120,
            type: WeaponTypes.LASER
          },
          {
            id: 'missile',
            name: 'MISSILE',
            desc: 'M√≠sseis teleguiados poderosos',
            price: 150,
            type: WeaponTypes.MISSILE
          }
        ],
        
        // Cat√°logo de armas auxiliares
        auxiliaryWeapons: [
          {
            id: 'orbital',
            name: 'ORBITAL',
            desc: 'üõ∏ Sat√©lites que orbitam e atiram',
            price: 50,
            type: AuxiliaryWeaponTypes.ORBITAL
          },
          {
            id: 'missile',
            name: 'MISSILE',
            desc: 'üöÄ M√≠sseis teleguiados autom√°ticos',
            price: 70,
            type: AuxiliaryWeaponTypes.MISSILE
          },
          {
            id: 'turret',
            name: 'TURRET',
            desc: 'üî´ Torreta lateral de fogo r√°pido',
            price: 60,
            type: AuxiliaryWeaponTypes.TURRET
          },
          {
            id: 'beam',
            name: 'BEAM',
            desc: '‚ö° Raios laterais cont√≠nuos',
            price: 65,
            type: AuxiliaryWeaponTypes.BEAM
          },
          {
            id: 'shield',
            name: 'SHIELD',
            desc: 'üõ°Ô∏è Escudo absorve 1 hit (3 min)',
            price: 100,
            type: AuxiliaryWeaponTypes.SHIELD
          }
        ],
        
        init() {
          const shopButton = document.getElementById('shopButton');
          const shopModal = document.getElementById('shopModal');
          const closeShop = document.getElementById('closeShop');
          
          // Abrir loja
          shopButton.addEventListener('click', () => this.open());
          
          // Fechar loja
          closeShop.addEventListener('click', () => this.close());
          shopModal.addEventListener('click', (e) => {
            if (e.target === shopModal) this.close();
          });
          
          // Sistema de abas
          const tabs = document.querySelectorAll('.shopTab');
          const tabContents = document.querySelectorAll('.shopTabContent');
          
          tabs.forEach(tab => {
            tab.addEventListener('click', () => {
              const targetTab = tab.getAttribute('data-tab');
              
              // Remove active de todas as abas
              tabs.forEach(t => t.classList.remove('active'));
              tabContents.forEach(tc => tc.classList.remove('active'));
              
              // Adiciona active na aba clicada
              tab.classList.add('active');
              document.getElementById(targetTab + 'Tab').classList.add('active');
            });
          });
          
          this.render();
        },
        
        open() {
          this.isOpen = true;
          game.isPaused = true; // Pausa o jogo
          document.getElementById('shopModal').classList.add('active');
          this.render();
        },
        
        close() {
          this.isOpen = false;
          game.isPaused = false; // Despausa o jogo
          document.getElementById('shopModal').classList.remove('active');
        },
        
        render() {
          // Atualiza moedas
          document.getElementById('shopCoins').textContent = game.coins;
          
          // Atualiza slots de auxiliares
          const auxSlots = game.player.auxiliaryWeapons.length;
          document.getElementById('auxSlots').textContent = `${auxSlots}/3`;
          
          // Renderiza upgrades
          this.renderUpgrades();
          
          // Renderiza armas prim√°rias
          const primaryContainer = document.getElementById('primaryWeapons');
          primaryContainer.innerHTML = '';
          
          this.primaryWeapons.forEach(weapon => {
            const isOwned = game.player.primaryWeapon.name === weapon.name;
            const canBuy = game.coins >= weapon.price;
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'shopItem' + (isOwned ? ' owned' : '');
            itemDiv.innerHTML = `
              <div class="itemInfo">
                <div class="itemName">${weapon.name}</div>
                <div class="itemDesc">${weapon.desc}</div>
              </div>
              <div class="itemPrice">
                <span style="color: #FFD700; font-size: 18px; font-weight: bold;">
                  ${weapon.price} ‚≠ê
                </span>
                <button class="buyButton" 
                  ${!canBuy || isOwned ? 'disabled' : ''}
                  onclick="ShopSystem.buyPrimary('${weapon.id}')">
                  ${isOwned ? 'EQUIPADA' : 'COMPRAR'}
                </button>
              </div>
            `;
            primaryContainer.appendChild(itemDiv);
          });
          
          // Renderiza armas auxiliares
          const auxContainer = document.getElementById('auxiliaryWeapons');
          auxContainer.innerHTML = '';
          
          this.auxiliaryWeapons.forEach(weapon => {
            const isOwned = game.player.auxiliaryWeapons.some(w => w.name === weapon.name);
            const canBuy = game.coins >= weapon.price && auxSlots < 3;
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'shopItem' + (isOwned ? ' owned' : '');
            itemDiv.innerHTML = `
              <div class="itemInfo">
                <div class="itemName">${weapon.name}</div>
                <div class="itemDesc">${weapon.desc}</div>
              </div>
              <div class="itemPrice">
                <span style="color: #FFD700; font-size: 18px; font-weight: bold;">
                  ${weapon.price} ‚≠ê
                </span>
                <button class="buyButton" 
                  ${!canBuy || isOwned ? 'disabled' : ''}
                  onclick="ShopSystem.buyAuxiliary('${weapon.id}')">
                  ${isOwned ? 'EQUIPADA' : auxSlots >= 3 ? 'SEM SLOT' : 'COMPRAR'}
                </button>
              </div>
            `;
            auxContainer.appendChild(itemDiv);
          });
        },
        
        buyPrimary(weaponId) {
          const weapon = this.primaryWeapons.find(w => w.id === weaponId);
          if (!weapon) return;
          
          if (game.coins >= weapon.price) {
            game.coins -= weapon.price;
            game.player.primaryWeapon = new WeaponInstance(weapon.type);
            
            // Salva progresso
            SaveSystem.save();
            
            // Feedback visual
            this.showPurchaseEffect('Arma Prim√°ria Adquirida!');
            this.render();
          }
        },
        
        buyAuxiliary(weaponId) {
          const weapon = this.auxiliaryWeapons.find(w => w.id === weaponId);
          if (!weapon) return;
          
          if (game.coins >= weapon.price && game.player.auxiliaryWeapons.length < 3) {
            game.coins -= weapon.price;
            game.player.auxiliaryWeapons.push(new WeaponInstance(weapon.type));
            
            // Salva progresso
            SaveSystem.save();
            
            // Feedback visual
            this.showPurchaseEffect('Arma Auxiliar Adquirida!');
            this.render();
          }
        },
        
        // Cat√°logo de upgrades
        upgrades: [
          {
            id: 'damage',
            name: 'üí• DANO',
            desc: 'Aumenta o dano de todas as armas',
            maxLevel: 5,
            basePrice: 40,
            priceIncrease: 30,
            effect: (level) => `+${level * 20}% Dano`
          },
          {
            id: 'speed',
            name: '‚ö° VELOCIDADE',
            desc: 'Aumenta a velocidade de movimento',
            maxLevel: 5,
            basePrice: 35,
            priceIncrease: 25,
            effect: (level) => `+${level * 15}% Velocidade`
          },
          {
            id: 'maxHealth',
            name: '‚ù§Ô∏è VIDA M√ÅXIMA',
            desc: 'Aumenta sua vida m√°xima',
            maxLevel: 5,
            basePrice: 50,
            priceIncrease: 40,
            effect: (level) => `+${level} HP (Max: ${5 + level})`
          },
          {
            id: 'fireRate',
            name: 'üî• TAXA DE TIRO',
            desc: 'Reduz o tempo entre disparos',
            maxLevel: 5,
            basePrice: 45,
            priceIncrease: 35,
            effect: (level) => `-${level * 10}% Cooldown`
          },
          {
            id: 'regen',
            name: 'üíö REGENERA√á√ÉO',
            desc: 'Regenera 1 HP a cada 10 segundos',
            maxLevel: 1,
            basePrice: 150,
            priceIncrease: 0,
            effect: (level) => level ? 'ATIVO' : 'INATIVO'
          }
        ],
        
        buyUpgrade(upgradeId) {
          const upgrade = this.upgrades.find(u => u.id === upgradeId);
          if (!upgrade) return;
          
          const currentLevel = game.upgrades[upgradeId] === true ? 1 : (game.upgrades[upgradeId] || 0);
          
          // Verifica se j√° est√° no n√≠vel m√°ximo
          if (currentLevel >= upgrade.maxLevel) return;
          
          // Calcula pre√ßo
          const price = upgrade.basePrice + (currentLevel * upgrade.priceIncrease);
          
          if (game.coins >= price) {
            game.coins -= price;
            
            // Aplica upgrade
            if (upgradeId === 'regen') {
              game.upgrades[upgradeId] = true;
            } else {
              game.upgrades[upgradeId]++;
            }
            
            // Aplica efeitos ao player
            SaveSystem.applyUpgradesToPlayer();
            
            // Salva progresso
            SaveSystem.save();
            
            // Feedback visual
            this.showPurchaseEffect(`${upgrade.name} Melhorado!`);
            this.render();
          }
        },
        
        renderUpgrades() {
          const upgradesList = document.getElementById('upgradesList');
          upgradesList.innerHTML = '';
          
          this.upgrades.forEach(upgrade => {
            const currentLevel = upgrade.id === 'regen' 
              ? (game.upgrades[upgrade.id] ? 1 : 0)
              : (game.upgrades[upgrade.id] || 0);
            const isMaxed = currentLevel >= upgrade.maxLevel;
            const price = upgrade.basePrice + (currentLevel * upgrade.priceIncrease);
            const canBuy = game.coins >= price && !isMaxed;
            
            const upgradeDiv = document.createElement('div');
            upgradeDiv.className = 'upgradeItem' + (isMaxed ? ' maxed' : '');
            upgradeDiv.innerHTML = `
              <div class="upgradeHeader">
                <div class="upgradeTitle">${upgrade.name}</div>
                <div class="upgradeLevel">N√≠vel ${currentLevel}/${upgrade.maxLevel}</div>
              </div>
              <div class="upgradeDesc">${upgrade.desc}</div>
              <div class="upgradeEffect">‚Üí ${upgrade.effect(currentLevel)}</div>
              <div class="upgradeFooter">
                <span style="color: #FFD700; font-size: 18px; font-weight: bold;">
                  ${price} ‚≠ê
                </span>
                <button class="buyButton" 
                  ${!canBuy ? 'disabled' : ''}
                  onclick="ShopSystem.buyUpgrade('${upgrade.id}')">
                  ${isMaxed ? 'M√ÅXIMO' : 'MELHORAR'}
                </button>
              </div>
            `;
            upgradesList.appendChild(upgradeDiv);
          });
        },
        
        showPurchaseEffect(message) {
          // Cria um texto flutuante de compra
          const effect = document.createElement('div');
          effect.textContent = '‚úÖ ' + message;
          effect.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 24px;
            font-weight: bold;
            z-index: 3000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: purchasePopup 1.5s ease-out forwards;
          `;
          
          document.body.appendChild(effect);
          
          setTimeout(() => effect.remove(), 1500);
        }
      };
      
      // CSS para anima√ß√£o de compra
      const style = document.createElement('style');
      style.textContent = `
        @keyframes purchasePopup {
          0% {
            transform: translate(-50%, -50%) scale(0.5);
            opacity: 0;
          }
          50% {
            transform: translate(-50%, -50%) scale(1.1);
            opacity: 1;
          }
          100% {
            transform: translate(-50%, -50%) scale(1) translateY(-30px);
            opacity: 0;
          }
        }
      `;
      document.head.appendChild(style);
      
      // Inicializa a loja ap√≥s o jogo
      loadImages(ASSETS, () => {
        game.init();
        ShopSystem.init();
      });
    </script>
  </body>
</html>
